<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>修仙RPG｜野外地圖＆戰鬥</title>
  <style>
    :root{
      --bg:#0b1024; --bg2:#0e1536; --panel:#131a3f; --panel-2:#0f1534; --muted:#9aa3b2; --text:#eaf2ff;
      --accent:#8b5cf6; --accent2:#22d3ee; --hp:#ef4444; --mp:#3b82f6; --bar:#334155; --ok:#22c55e; --warn:#f59e0b;
      --gold:#b98c4b; --gold-2:#7a5b31; --radius:16px; --gap:12px; --shadow:0 10px 28px rgba(0,0,0,.35);
      --elem-none:#64748b; --elem-gold:#f59e0b; --elem-wood:#22c55e; --elem-water:#38bdf8;
      --elem-fire:#f97316; --elem-earth:#a16207; --elem-spirit:#a78bfa; --elem-dark:#0f172a;
    }
    *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
    html,body{height:100%; margin:0; font-family:"Microsoft JhengHei",system-ui,Segoe UI,Roboto,sans-serif; color:var(--text); background:var(--bg);}

    .stage{
      position:fixed; inset:0;
      display:grid;
      align-items:start;            /* 讓畫面貼齊頂部*/
      justify-items:center;
      overflow:auto;
      padding-top:env(safe-area-inset-top); /* 保留瀏海安全區 */
    }

    .app{
      aspect-ratio: 93/150;
      width: min(100svw, calc(100svh * 93/150));
      max-height: 100svh;
      background: linear-gradient(180deg, var(--bg2), var(--panel));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      display:flex; flex-direction:column; overflow:hidden;
    }
    /* 手機直立優化：讓 App 直接填滿視窗，去掉上下黑邊 */
    @media (max-width: 480px){
      .app{
        width: 100svw;
        height: 100svh;       /* 直接吃滿可視高度 */
        max-height: none;
        aspect-ratio: auto;   /* 取消固定比例 */
        border-radius: 0;     /* 視覺貼齊螢幕邊緣（可移除） */
      }
    }

    /* Header */
    header{
      padding:10px 12px; background:rgba(255,255,255,.06);
      border-bottom:1px solid rgba(255,255,255,.08);
      display:grid; grid-template-columns:1fr auto; grid-template-areas: "left right" "medals right";
      gap:8px 10px; align-items:center;
    }
    .h-left{grid-area:left; display:grid; grid-template-columns:auto 1fr; gap:10px; align-items:center; min-width:0;}
    .avatar{width:44px; height:44px; border-radius:50%; object-fit:cover; background:#222; border:2px solid rgba(255,255,255,.15);}
    .pinfo{display:flex; flex-direction:column; min-width:0;}
    .prow{display:flex; align-items:center; gap:6px; flex-wrap:nowrap; min-width:0;}
    .pname{font-weight:700; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .plv{font-size:12px; opacity:.9;}
    .pill{
      display: inline-flex;
      align-items: center;
      gap: 2px;
      padding: 1px 5px;
      border-radius: 999px;
      font-size: 10px;
      background: rgba(255,255,255,0.08);
    }
    .pill.elem{ color:#fff; font-weight:600; }
    .pill.elem.none{  background:var(--elem-none);  }
    .pill.elem.gold{  background:var(--elem-gold);  }
    .pill.elem.wood{  background:var(--elem-wood);  }
    .pill.elem.water{ background:var(--elem-water); }
    .pill.elem.fire{  background:var(--elem-fire);  }
    .pill.elem.earth{ background:var(--elem-earth); }
    .pill.elem.spirit{background:var(--elem-spirit);}
    .pill.elem.dark{  background:var(--elem-dark);  }

    .medals{grid-area:medals; display:flex; gap:6px; min-width:0;}
    .medal-slot{width:30px; aspect-ratio:1/1; border-radius:50%; border:2px solid rgba(255,255,255,.25);
      display:flex; align-items:center; justify-content:center; font-size:12px; color:#cbd5e1; background:rgba(255,255,255,.06);
      overflow:hidden; flex:0 0 auto;}
    .h-right{grid-area:right; display:flex; flex-direction:column; align-items:flex-end; gap:8px; min-width:0;}
    .coins{display:flex; gap:8px; white-space:nowrap; min-width:0; flex-wrap:nowrap;}
    .coin{display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); font-size:12px;}
    .icon-box{ width:18px; height:18px; border-radius:4px; overflow:hidden; display:grid; place-items:center; }
    .icon-box img{ width:100%; height:100%; object-fit:cover; display:block; }
    .val{max-width:140px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}
    .back-btn{padding:5px 10px; min-width:76px; font-size:12px; border-radius:999px; border:1px solid rgba(255,255,255,.2); background:#111827; color:#fff; font-weight:800; cursor:pointer; letter-spacing:.5px;}
    .logout-btn{padding:5px 10px; min-width:76px; font-size:12px; border-radius:999px; border:1px solid rgba(255,255,255,.2); background:#ef4444; color:#fff; font-weight:800; cursor:pointer; letter-spacing:.5px;}

    .divider{height:1px; background:rgba(255,255,255,.08); margin:1px 0;}
    .main{flex:1; display:flex; flex-direction:column; gap:10px; padding:8px 12px 10px; overflow:auto;}

    /* Bars（縮小字級＋更細能量條） */
    .bars{
      display: grid;
      gap: 2px;
    }
    .stat-row{display:grid; grid-template-columns:48px 1fr 56px; align-items:center; gap:6px;}
    .label{font-size:12px; color:#e2e8f0; text-align:right;}
    .num{font-size:11px; color:#e2e8f0; text-align:right;}
    .prog{height:8px; background:#1f273a; border-radius:999px; position:relative; overflow:hidden; box-shadow: inset 0 1px 0 rgba(255,255,255,.06), inset 0 -1px 0 rgba(0,0,0,.25);}
    .fill{height:100%; width:0%;}
      .fill.sta{background:linear-gradient(90deg,#eab308,#f59e0b);}
      .fill.exp{background:linear-gradient(90deg,#16a34a,#4ade80);}
      .fill.hp{background:linear-gradient(90deg,#ef4444,#b91c1c);}
      .fill.mp{background:linear-gradient(90deg,#3b82f6,#1d4ed8);}

    /* Map selection */
    .map-wrap{display:grid; gap:10px;}
    .title{text-align:center; color:#c7d2fe; font-weight:900; letter-spacing:4px; padding-top:2px; font-size:14px;}

    /* 兩列選單：左＝大地圖（清單）／右＝副地圖（清單） */
    .map-select{display:grid; grid-template-columns: 1fr 1fr; gap:10px;}
    .col{
      background:rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.08);
      border-radius:14px; padding:8px; display:grid; grid-template-rows:auto 1fr;
      gap:8px; min-height:160px;
    }
    .col .clabel{font-size:12px; color:#a5b4fc; letter-spacing:2px;}
    .col .opts{
      display:flex; flex-direction:column; gap:6px; overflow:auto; padding-right:2px;
      -webkit-overflow-scrolling:touch;
    }
    /* 清單條目（字小、整行可點） */
    .tag{
      display:flex; align-items:center; justify-content:space-between; width:100%;
      padding:6px 10px; font-size:12px; border-radius:10px;
      border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.06);
      cursor:pointer; user-select:none;
    }
    .tag .name{flex:1; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}
    .tag .lv{margin-left:8px; font-size:11px; color:#93c5fd; opacity:.95; white-space:nowrap;}
    .tag{padding:4px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.10); cursor:pointer; user-select:none; font-size:11px; line-height:1.1;}
    .tag.active{background:linear-gradient(135deg,var(--accent),var(--accent2));}

    /* 進入/動作區 */
    .panel{background:rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:8px; display:grid; gap:8px;}
    .btn {
      padding: 3px 7px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.18);
      background: linear-gradient(135deg,var(--accent),var(--accent2));
      color: #fff;
      font-weight: 500;
      font-size: 11px;  /* 新增字體大小 */
      text-align: center;
      cursor: pointer;
      user-select: none;
    }

    .btn.ghost{background:transparent; color:#fff; border:1px solid rgba(255,255,255,.2);}
    .btn[disabled]{opacity:.5; filter:grayscale(1); cursor:not-allowed;}

    .row{display:flex; gap:8px; flex-wrap:wrap;}
    .hint{font-size:9px; color:#93c5fd; text-align:center;}

   /* === 地區情報（固定欄位・雙欄） === */
    .panel.info{ padding:6px 8px; }
    .info-title{
      font-size:11px; color:#a5b4fc; letter-spacing:1.5px;
      margin-bottom:4px; opacity:.95;
    }
    /* 固定雙欄：左欄較寬（怪物），右欄稍窄（事件） */
    .info-grid{
      display:grid; grid-template-columns: minmax(0,1.35fr) minmax(0,.85fr);
      gap:6px 10px; align-items:start;
    }
    .info-col{ display:grid; gap:4px; min-width:0; }
    .info-label{ font-size:11px; color:#e2e8f0; opacity:.8; }

    /* 怪物膠囊（更緊湊） */
    .chip-list{ display:flex; flex-wrap:wrap; gap:6px; }
    .chip{
      display:inline-flex; align-items:center; gap:6px;
      padding:3px 6px; border-radius:8px;
      border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.08);
      font-size:11px; line-height:1.1; white-space:nowrap;
      max-width:100%;
    }
    .chip .mname{
      max-width:120px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
    }
    .chip .mlv{ font-size:10px; opacity:.75; }

    /* 地區情報中的元素膠囊縮小一號 */
    .info .pill.elem{
      padding:0 6px; border-radius:8px;
      font-size:10px; line-height:1.1;
    }

    /* 事件列表（真正齊頭：把分隔點放在前一個項目的尾端） */
    .event-list{
      display:flex; flex-wrap:wrap; gap:6px 10px;
      margin:0; padding:0; list-style:none; font-size:11px; color:#cbd5e1;
    }
    .event-list li{
      display:flex; align-items:center;
    }
    .event-list li::before{ content:''; } /* 清空上一版的前置點（避免快取造成殘留） */
    .event-list li:not(:last-child)::after{
      content:'・'; margin-left:6px; opacity:.55;
    }


    /* Battle UI */
    .battle{display:none; grid-template-rows:auto 1fr auto; gap:10px; min-height:340px;}
    .battle.show{display:grid;}
    .arena{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 3px;
      align-items: end;
      padding: 8px;
      border-radius: 25px;
      background: rgb(206 224 231 / 23%);
      border: 1px solid rgba(255,255,255,.12);
    }
    .box{
      background: rgba(0,0,0,.3);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 10px;
      padding: 3px;
      display: grid;
      gap: 2px;
    }
    /* 立繪容器（保留一點邊距） */
    .art{
      width: 100%;
      height: 125px;
      border-radius: 10px;
      background: linear-gradient(180deg,rgba(255,255,255,.05),rgba(0,0,0,.15));
      display: grid;
      place-items: center;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,.08);
      position: relative;
    }

    /* 100×100 頭像框：玩家圓形、敵人方形 */
    .frame{
      width: 140px;
      height: 120px;
      display: grid;
      place-items: center;
      overflow: hidden;
      background: rgba(0,0,0,.15);
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
      align-items: stretch;
    }
    .p-frame{ border-radius:8px; }        /* 玩家圓形 */
    .e-frame{ border-radius:8px; }       /* 敵人方形，帶一點圓角 */

    /* 內部圖片：以 100×100 素材為主，保持完整顯示 */
    .portrait{
      width: 130px;
      height: 110px;
      object-fit: contain;
      display: block;
      image-rendering: auto;
      filter: drop-shadow(0 4px 6px rgba(0,0,0,.35));
      transition: opacity 600ms ease, transform 600ms ease;
    }
    .portrait.mirror{ transform: scaleX(-1); }
    .portrait.fade-out{ opacity:0; transform: scale(0.96); }

    /* ★ 新增：每次遭遇怪物的翻轉進場動畫（掛在敵人框 .e-frame 上，不影響 .mirror） */
    @keyframes flipIn {
      0%   { transform: perspective(600px) rotateY(90deg) scale(0.95); opacity:0; }
      50%  { transform: perspective(600px) rotateY(10deg) scale(1.02); opacity:1; }
      100% { transform: perspective(600px) rotateY(0deg)  scale(1.00); opacity:1; }
    }
    .e-frame.flip-in{
      animation: flipIn 520ms ease;
    }



    .who{display:flex; align-items:center; justify-content:space-between; gap:8px;}
    .name {
    font-weight: 900;
    font-size: 8pt;
    }

    .hpbar{height:6px; background:#1f273a; border-radius:999px; overflow:hidden;}
    .hpfill{height:100%; width:0%; background:linear-gradient(90deg,#ef4444,#b91c1c);}
    .atb{height:6px; background:#0b122b; border-radius:999px; overflow:hidden;}
    .atbfill{height:100%; width:0%; background:linear-gradient(90deg,#22d3ee,#8b5cf6);}
    .srow{display:flex; gap:10px; font-size:12px; color:#cbd5e1;}
    .cmd{display:grid; grid-template-columns:repeat(4,1fr); gap:8px;}
    .cbtn{
    padding: 4px 6px;
    text-align: center;
    border-radius: 16px;
    border: 1px solid rgba(255,255,255,.2);
    background: linear-gradient(#a6783e,#7f5626);
    box-shadow: inset 0 2px 0 rgba(255,255,255,.15), 0 2px 0 rgba(0,0,0,.2);
    font-weight: 800;
    letter-spacing: 2px;
    color: #fff;
    cursor: pointer;
    user-select: none;
    }
    .cbtn[disabled]{opacity:.5; filter:grayscale(1); cursor:not-allowed;}
    /* ★ 改善戰鬥／地圖日誌：加大、加行距、背景透黑，並加入分類色 */
    .log{
      height: 100px;
      overflow: auto;
      padding: 10px 12px;
      font-size: 10px;
      line-height: 1.35;
      background: rgba(6,10,26,0.8);
      border: 1px solid rgba(255,255,255,.3);
      border-radius: 8px;
    }

    /* 攻擊按鈕 */
    #actAttack {
    background: linear-gradient(45deg, #8b0000, #dc143c);
    color: #ffd700;
    border: 2px solid #4b0000;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    }   


    /* 每條訊息底下留一點間距 */
    .log > div{ margin-bottom:4px; }
    /* 日誌分類顏色：呼應全域變數 ok/warn/hp 等 */
    .log .ok  { color: var(--ok);   }
    .log .warn{ color: var(--warn); }
    .log .hit { color: var(--hp);   }
    .log .crit{ color:#ffd166;     }
    .log .heal{ color:#34d399;     }


    .footrow{display:flex; gap:8px; justify-content:space-between; align-items:center;}
    .locBadge{font-size:10px; color:#e2e8f0;}

    /* ===== 受擊/浮字特效 ===== */
    .art{ position:relative; }            /* 讓 fx 可以絕對定位在立繪上 */
    .fx{ position:absolute; inset:0; pointer-events:none; overflow:visible; }
    .dmg-float{
      position:absolute; left:50%; top:45%;
      transform: translate(-50%,-50%);
      font-weight:900; font-size:22px; letter-spacing:1px;
      text-shadow:0 2px 0 rgba(0,0,0,.35), 0 0 12px rgba(255,255,255,.2);
      animation: rise 900ms ease-out forwards;
      user-select:none; white-space:nowrap;
    }
    .dmg-float.crit{ font-size:26px; filter: drop-shadow(0 0 8px rgba(255,215,0,.55)); }
    .dmg{ color:#ff6b6b; }
    .heal{ color:#34d399; }
    .crit{ color:#ffd166; }

    .flash{
      position:absolute; inset:0;
      background: radial-gradient( circle at 50% 45%, rgba(255,80,80,.55), rgba(255,0,0,.15) 60%, transparent 70% );
      mix-blend-mode: screen;
      border-radius:10px;
      animation: flash 220ms ease-out forwards;
    }

    .portrait.shake{ animation: shake .28s cubic-bezier(.36,.07,.19,.97) 2; transform-origin:center; }

    @keyframes flash{
      0%{ opacity:0; }
      10%{ opacity:.95; }
      100%{ opacity:0; }
    }
    @keyframes rise{
      0%{ transform:translate(-50%,-20%) scale(.9); opacity:0; }
      15%{ transform:translate(-50%,-40%) scale(1.05); opacity:1; }
      100%{ transform:translate(-50%,-110%) scale(1.0); opacity:0; }
    }
    @keyframes shake{
      10%, 90% { transform: translateX(-1px); }
      20%, 80% { transform: translateX(2px); }
      30%, 50%, 70% { transform: translateX(-4px); }
      40%, 60% { transform: translateX(4px); }
    } 

    /* === 技能橫幅 & 施放時的畫面滑動 === */
    .skill-banner{
      position: fixed; inset: 0; z-index: 9999; pointer-events: none;
      display: grid; place-items: center;
    }
    .skill-banner::before{
      content:''; position:absolute; inset:-10%;
      background: linear-gradient(120deg, transparent 30%, rgba(255,255,255,.08) 50%, transparent 70%);
      transform: translateX(-60%);
      animation: skillSweep 900ms ease-out forwards;
      mix-blend-mode: screen;
    }
    .skill-banner .wrap{
      padding: 8px 14px; border-radius: 12px;
      background: rgba(14,21,54,.45);
      border: 1px solid rgba(255,255,255,.25);
      backdrop-filter: blur(2px);
      text-align: center; letter-spacing: .2em;
      text-shadow: 0 1px 0 rgba(0,0,0,.6), 0 0 10px rgba(255,255,255,.15);
      font-weight: 900; color: #eaf2ff;
      opacity: 0; transform: translateY(-12px) scale(.98);
      animation: bannerIn 900ms ease-out forwards;
    }
    .skill-banner .title{ font-size: 12px; opacity:.85; margin-bottom: 4px; }
    .skill-banner .name{ font-size: 22px; }
    .skill-banner .elem-pill{
      display:inline-flex; align-items:center; gap:6px;
      padding:2px 8px; margin-top:6px; border-radius:999px; font-size:12px;
      border:1px solid rgba(255,255,255,.25); background: rgba(255,255,255,.08);
    }
    .skill-banner .elem-pill.wind{ background: var(--elem-water); color:#0b1024; } /* 風色系你可自行改 */

    @keyframes bannerIn{
      0%{ opacity:0; transform: translateY(-14px) scale(.98); }
      40%{ opacity:1; transform: translateY(0) scale(1.02); }
      100%{ opacity:1; transform: translateY(0) scale(1.0); }
    }
    @keyframes skillSweep{
      to{ transform: translateX(60%); }
    }
    /* 施放瞬間讓整個 App 有點位移（相機平移感） */
    .app.pan{
      animation: camPan 420ms cubic-bezier(.2,.8,.2,1);
    }
    @keyframes camPan{
      0%{ transform: translateX(0); }
      35%{ transform: translateX(-10px); }
      100%{ transform: translateX(0); }
    }

  </style>
</head>
<body>
<div class="stage">
  <div class="app">
    <header>
      <div class="h-left">
        <img id="uiAvatar" class="avatar" alt="avatar" />
        <div class="pinfo">
          <div class="prow">
            <div class="pname" id="uiName"></div>
            <div class="plv">LV.<span id="uiLv"></span></div>
            <span id="uiElem" class="pill elem none"></span>
          </div>
        </div>
      </div>
      <div class="medals">
        <div class="medal-slot" id="medal1"></div>
        <div class="medal-slot" id="medal2"></div>
        <div class="medal-slot" id="medal3"></div>
        <div class="medal-slot" id="medal4"></div>
        <div class="medal-slot" id="medal5"></div>
      </div>
      <div class="h-right">
        <div class="coins">
          <span class="coin">
            <span class="icon-box"><img alt="靈石" src="https://upload.wikimedia.org/wikipedia/commons/9/9d/Crystal_128_up.png"></span>
            <span class="val" id="uiStone">0</span>
          </span>
          <span class="coin">
            <span class="icon-box"><img alt="鑽石" src="https://upload.wikimedia.org/wikipedia/commons/0/0a/Diamond_Icon.svg"></span>
            <span class="val" id="uiDiamond">0</span>
          </span>
        </div>
        <div class="row">
          <button id="btnBackHome" class="back-btn" title="返回主城">返回主城</button>
          <button id="btnLogout" class="logout-btn" title="登出" aria-label="登出">登出</button>
        </div>
      </div>
    </header>

    <div class="divider"></div>

    <div class="main">
      <!-- 顯示體力/經驗/氣血 -->
    <div class="bars">
      <div class="stat-row">
        <div class="label">體力：</div>
        <div class="prog"><div class="fill sta" id="barSta"></div></div>
        <div class="num" id="txtSta">100/100</div>
      </div>
      <div class="stat-row">
        <div class="label">經驗：</div>
        <div class="prog"><div class="fill exp" id="barExp"></div></div>
        <div class="num" id="txtExp">0/100</div>
      </div>
      <div class="stat-row">
        <div class="label">氣血：</div>
        <div class="prog"><div class="fill hp" id="barHp"></div></div>
        <div class="num" id="txtHp">--/--</div>
      </div>
      <div class="stat-row">
        <div class="label">真元：</div>
        <div class="prog"><div class="fill mp" id="barMp"></div></div>
        <div class="num" id="txtMp">--/--</div>
      </div>
    </div>

<!-- 地圖選擇 -->
      <div id="mapSection" class="map-wrap">
        <div class="title">野 外 地 圖</div>

        <!-- 兩列選單：左大地圖、右副地圖（依左側選擇動態變化） -->
        <div class="map-select">
          <div class="col">
            <div class="clabel">大地圖</div>
            <div class="opts" id="bigMapCol"></div>
          </div>
          <div class="col">
            <div class="clabel">副地圖</div>
            <div class="opts" id="smallMapCol"></div>
          </div>
        </div>

        <!-- 先按「進入」才會顯示探險/戰鬥 -->
      <div class="panel">
        <div class="locBadge" id="locBadge">尚未選擇地點</div>
        <div class="row">
          <button id="btnEnter"   class="btn" disabled>進 入</button>
          <button id="btnExplore" class="btn" style="display:none;">探險（體力-2）</button>
          <button id="btnFight"   class="btn" style="display:none;">戰 鬥</button>
          <!-- ★ 新增：挑戰 BOSS（紅色） -->
          <button id="btnBoss"    class="btn" style="display:none; background:#b91c1c; border:1px solid #dc2626;">挑戰 BOSS</button>
        </div>
        <div class="hint">請先選擇「大地圖 → 副地圖」並按下「進入」。進入後才會顯示「探險 / 戰鬥」。</div>
        <!-- ★ 新增：萊姆洞窟進度提示 -->
        <div id="slimeQuestHint" class="hint" style="display:none;"></div>
      </div>

        <!-- ★ 地區情報（固定欄位｜雙欄：左=怪物，右=事件） -->
        <div class="panel info" id="areaInfo">
          <div class="info-title">地 區 情 報</div>
          <div class="info-grid">
            <div class="info-col info-left">
              <div class="info-label">可能出現的怪物</div>
              <div id="infoMonsters" class="chip-list"><span class="chip">—</span></div>
            </div>
            <div class="info-col info-right">
              <div class="info-label">探險可能事件</div>
              <ul id="infoEvents" class="event-list">
                <li>撿到靈石（約 50%）</li>
                <li>發現素材（約 30%）</li>
                <li>獲得丹藥（約 20%）</li>
              </ul>
            </div>
          </div>
        </div>

        <!-- ★ 事件／戰鬥日誌（與戰鬥共用同一個 #log） -->
        <div class="panel">
          <div class="log" id="logMap"></div>
        </div>
      </div>

      <!-- 戰鬥場景 -->
      <div id="battleSection" class="battle">
        <div class="arena">
        <div class="box">
          <div class="who">
          <div class="name">你</div>
          <div class="srow">
            <span>LV.<span id="pLv"></span></span>
            <span id="pElem" class="pill elem">—</span>
          </div>
        </div>
          <div class="art">
            <div class="frame p-frame">
              <img id="pImg" class="portrait" alt="player portrait">
            </div>
            <div class="fx" id="pFx"></div>
          </div>
          <div class="hpbar"><div id="pHp" class="hpfill"></div></div>
          <div class="atb"><div id="pATB" class="atbfill"></div></div>
        </div>
        <div class="box">
          <div class="who">
          <div class="name" id="eName">敵人</div>
          <div class="srow">
            <span>LV.<span id="eLv"></span></span>
            <span id="eElem" class="pill elem">—</span>
          </div>
        </div>
          <div class="art">
            <div class="frame e-frame">
              <img id="eImg" class="portrait mirror" alt="enemy portrait">
            </div>
            <div class="fx" id="eFx"></div>
          </div>
          <div class="hpbar"><div id="eHp" class="hpfill"></div></div>
          <div class="atb"><div id="eATB" class="atbfill"></div></div>
        </div>
        </div>
        <div class="cmd">
          <button id="actAttack" class="cbtn" disabled>攻 擊</button>
          <button id="actSkill"  class="cbtn" disabled title="預留">技 能</button>
          <button id="actItem"   class="cbtn" disabled>道 具</button>
          <button id="actRun"    class="cbtn" disabled>逃 跑</button>
        </div>
        <div class="log" id="logBattle"></div>
        <div class="footrow">
          <div id="btState" class="locBadge"></div>
          <div class="row">
            <button id="btnLeaveBattle" class="btn ghost" style="display:none;">返回小地圖</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Firebase（compat 版，免 ES Module） -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
<script>
  (function(){
    var firebaseConfig = {
      apiKey: "AIzaSyBvKmn0jCTS_jIgEYOuQjc8vyYU40Q5F3I",
      authDomain: "stellarblue-system.firebaseapp.com",
      databaseURL: "https://stellarblue-system-default-rtdb.firebaseio.com",
      projectId: "stellarblue-system",
      storageBucket: "stellarblue-system.firebasestorage.app",
      messagingSenderId: "803212433649",
      appId: "1:803212433649:web:887080d10a51d533b23150",
      measurementId: "G-YY94484DV9"
    };
    if(!firebase.apps || !firebase.apps.length){
      firebase.initializeApp(firebaseConfig);
    }
    // 提供給 auth.js 使用
    window.DB = firebase.database();
  })();
</script>
<!-- 資料庫/帳號 -->
<script src="stats.js"></script>
<script src="items.js"></script>
<script src="skills.js"></script>
<script src="monsters.js"></script>
<script src="equip.js"></script><!-- ★新增：裝備模組，確保 getBonuses 一致 -->
<script src="auth.js"></script>


<script>
/* ===== 工具 ===== */
const qs = (s, p=document)=>p.querySelector(s);
const qsa = function(s, p){
  p = p || document;
  return Array.prototype.slice.call(p.querySelectorAll(s));
};
const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
const pct=(cur,max)=> (max>0? clamp(Math.round(cur/max*100),0,100) : 0);
const fmt=(n)=> new Intl.NumberFormat('zh-Hant').format(n);

/* ===== 元素系統（已移至 stats.js） ===== */
// 所有元素相關函數都在 stats.js 中定義
// 這裡只需要確保能正常使用即可



// 玩家預設立繪（若沒有 avatar 才用這張）
const PLAYER_IMG_URL = 'https://picsum.photos/seed/xian-hero/400/600';



/* ===== 地圖資料（大地圖 -> 小地圖） ===== */
const MAPS = [
{ id:'forest', name:'青木山脈', lv:'1-10', small:[
  { id:'slime_cave',  name:'萊姆洞窟', lv:'1-3',
    monsters:['slime_young','slime','slime_king'], 
    boss:'slime_boss', killsRequired: 8 },
  { id:'woodland',    name:'火林洞',   lv:'4-7',
    monsters:['wood_wisp','Fire_Spirit','laily',"fire_orb"], 
    boss:'flame_master', killsRequired: 12 },
  { id:'moss_vale',   name:'苔石谷',   lv:'2-4',
    monsters:['slime','stone_golem'],  
    boss:'stone_golem_boss', killsRequired: 10 },
]},
{ id:'tundra', name:'雪原台地', lv:'3-5', small:[
  { id:'snowfield',   name:'雪原狩場', lv:'3-4',
    monsters:['snow_wolf','ice_thorn'], 
    boss:'ice_bear_boss', killsRequired: 10 },
  { id:'ice_cave',    name:'寒晶洞穴', lv:'4-5',
    monsters:['ice_bear','ice_thorn'], 
    boss:'ice_cave_boss', killsRequired: 12 },  // ★ 加上 boss
]},
{ id:'ruins', name:'幽怨遺跡', lv:'5-7', small:[
  { id:'spirit_hall', name:'靈侍大殿', lv:'4-6',
    monsters:['spirit_acolyte','wraith'], 
    boss:'spirit_acolyte_boss', killsRequired: 15 },
  { id:'shadow_pit',  name:'影翼深坑', lv:'4-6',
    monsters:['shadow_bat','wraith'],     
    boss:'shadow_bat_boss', killsRequired: 15 },
]},
{ id:'canyon', name:'磐石峽谷', lv:'3-6', small:[
  { id:'beetle_ridge', name:'雷角嶺',  lv:'5-6',
    monsters:['brass_beetle','thunder_beetle'], 
    boss:'thunder_beetle_boss', killsRequired: 18 },
  { id:'bog',          name:'泥潭窪地',lv:'3-5',
    monsters:['bog_tortoise','stone_golem'],    
    boss:'ancient_tortoise_boss', killsRequired: 14 },
]},
];



/* ===== 玩家/導入角色 ===== */
let P = null;           // 玩家角色
let curBig = null;      // 現在選的大地圖 id
let curSmall = null;    // 現在選的小地圖 id
let entered = false;    // 是否已按「進入」，未進入前不顯示探險/戰鬥

// 取得玩家（從 Auth / localStorage）
function loadPlayer(){
  if(!window.Auth || !Auth.getCharacter){ alert('找不到帳號系統'); return null; }
  const c = Auth.getCharacter();
  if(!c){ location.href = 'index.html#create'; return null; }

  // 確保背包存在 & 結構齊全
  if(!c.bag){
    c.bag = (window.ItemDB && ItemDB.getDefaultBag) ? ItemDB.getDefaultBag() 
      : { consumables:[], weapons:[], ornaments:[], materials:[], hidden:[] };
  }else{
    c.bag.consumables = Array.isArray(c.bag.consumables) ? c.bag.consumables : [];
    c.bag.weapons     = Array.isArray(c.bag.weapons)     ? c.bag.weapons     : [];
    c.bag.ornaments   = Array.isArray(c.bag.ornaments)   ? c.bag.ornaments   : [];
    c.bag.materials   = Array.isArray(c.bag.materials)   ? c.bag.materials   : [];
    c.bag.hidden      = Array.isArray(c.bag.hidden)      ? c.bag.hidden      : [];
  }

  // HP 欄位若不存在，建立（沿用你的衍生規則）
  if(!c.hp){ 
    const d=derivedFrom(c); 
    c.hp = { cur:d['氣血上限'], max:d['氣血上限'] }; 
  }
}

async function savePlayer(){
  try{
    if (typeof P !== 'undefined' && P){
      // 標記本地時間戳，主城/其他頁比對快取與雲端時會選用較新版本
      P._updatedAt = Date.now();

      if (window.Auth){
        // ★ Firebase 安全處理：移除 _live 避免特殊字符問題
        var saveData = JSON.parse(JSON.stringify(P)); // 深拷貝
        delete saveData._live; // 移除包含特殊字符的 _live 物件
        
        // ★ 強制同步：先更新本地快取
        if (Auth.setCharacter) {
          try{ 
            Auth.setCharacter(saveData); 
            console.log('✅ 本地快取已更新:', saveData.level, saveData.exp, saveData.hp, saveData.sta);
          }catch(_e){
            console.error('❌ 本地快取更新失敗:', _e);
          }
        }
        
        // ★ 強制同步：再寫雲端（加重試機制）
        if (Auth.saveCharacter) {
          var retries = 3;
          while(retries > 0){
            try{
              await Auth.saveCharacter(saveData);
              console.log('✅ 雲端存檔成功:', saveData.level, saveData.exp);
              break;
            }catch(saveErr){
              retries--;
              console.warn('⚠️ 雲端存檔失敗，剩餘重試次數:', retries, saveErr);
              if(retries > 0) await new Promise(r => setTimeout(r, 500)); // 等待 500ms 重試
            }
          }
        }
      }
    }
  }catch(e){
    console.error('❌ savePlayer 整體失敗:', e);
  }
}








// === 只算一次的「最終能力快照」：基礎衍生 + 裝備加成 ===
function finalDerived(player){
  var base  = (typeof derivedFrom==='function') ? (derivedFrom(player)||{}) : {};
  var bonus = (window.Equip && typeof Equip.getBonuses==='function') ? (Equip.getBonuses()||{}) : {};
  var out = {};
  // 相當於 { ...base }
  for (var k in base) {
    if (Object.prototype.hasOwnProperty.call(base, k)) out[k] = base[k];
  }
  // 疊加裝備加成
  for (var k2 in bonus) {
    if (Object.prototype.hasOwnProperty.call(bonus, k2)) {
      out[k2] = (out[k2]||0) + (bonus[k2]||0);
    }
  }
  return out;
}



// 重新整理快照（進地圖、開始戰鬥、升級後都可呼叫）
function refreshLive(){
  if(!P) return;
  P._live = finalDerived(P);
}

/* ===== UI Render ===== */
function renderHeader(){
  const fallbackAvatar = (typeof Auth!=='undefined' && Auth.defaultAvatar)
    ? (Auth.defaultAvatar() || 'https://picsum.photos/seed/xian/96')
    : 'https://picsum.photos/seed/xian/96';
  qs('#uiAvatar').src = P.avatar || fallbackAvatar;
  qs('#uiName').textContent = P.name || '無名散修';
  qs('#uiLv').textContent   = P.level ?? 1;
  const elem = (P.element || 'none').toLowerCase();
  const elemEl = qs('#uiElem'); elemEl.className = `pill elem ${elem}`; elemEl.textContent = ELEMENT_LABEL[elem] || '無元素';

  qs('#uiStone').textContent   = fmt(P.currencies?.stone || 0);
  qs('#uiDiamond').textContent = fmt(P.currencies?.diamond || 0);
}

 // 玩家進入後連動的能量條

function renderBars(){
  if (!P) return;
  if (!P._live) refreshLive();

  // —— 以 API 狀態為主：僅補預設、限制範圍，不自行回滿 —— //
  if (!P.sta){ P.sta = { cur:100, max:100 }; }
  else{
    if (typeof P.sta.max !== 'number' || P.sta.max <= 0) P.sta.max = 100;
    if (typeof P.sta.cur !== 'number') P.sta.cur = P.sta.max;
    if (P.sta.cur > P.sta.max) P.sta.cur = P.sta.max;
    if (P.sta.cur < 0) P.sta.cur = 0;
  }

  if (!P.exp){ P.exp = { cur:0, max:100 }; }
  else{
    if (typeof P.exp.max !== 'number' || P.exp.max <= 0) P.exp.max = 100;
    if (typeof P.exp.cur !== 'number') P.exp.cur = 0;
    if (P.exp.cur > P.exp.max) P.exp.cur = P.exp.max;
    if (P.exp.cur < 0) P.exp.cur = 0;
  }

  // 上限統一：基礎 + 裝備加成（與主城相同計算）
  var base  = derivedFrom(P);
  var bonus = (window.Equip && typeof Equip.getBonuses === 'function') ? (Equip.getBonuses() || {}) : {};
  var hpMax = (base['氣血上限'] || 0) + (bonus['氣血上限'] || 0);
  var mpMax = (base['真元上限'] || 0) + (bonus['真元上限'] || 0);

  if (!P.hp){ P.hp = { cur: hpMax, max: hpMax }; }
  else{
    P.hp.max = hpMax;
    if (typeof P.hp.cur !== 'number') P.hp.cur = hpMax;
    if (P.hp.cur > P.hp.max) P.hp.cur = P.hp.max;
    if (P.hp.cur < 0) P.hp.cur = 0;
  }

  if (!P.mp){ P.mp = { cur: mpMax, max: mpMax }; }
  else{
    P.mp.max = mpMax;
    if (typeof P.mp.cur !== 'number') P.mp.cur = mpMax;
    if (P.mp.cur > P.mp.max) P.mp.cur = P.mp.max;
    if (P.mp.cur < 0) P.mp.cur = 0;
  }

  // —— 畫面更新（純讀 P） —— //
  var staBar = qs('#barSta'); if (staBar){ staBar.style.width = (P.sta.cur / P.sta.max * 100) + '%'; }
  var staTxt = qs('#txtSta'); if (staTxt){ staTxt.textContent = P.sta.cur + '/' + P.sta.max; }

  var expBar = qs('#barExp'); if (expBar){ expBar.style.width = (P.exp.cur / P.exp.max * 100) + '%'; }
  var expTxt = qs('#txtExp'); if (expTxt){ expTxt.textContent = P.exp.cur + '/' + P.exp.max; }

  var hpBar = qs('#barHp'); if (hpBar){ hpBar.style.width = (P.hp.cur / P.hp.max * 100) + '%'; }
  var hpTxt = qs('#txtHp'); if (hpTxt){ hpTxt.textContent = P.hp.cur + '/' + P.hp.max; }

  var mpBar = qs('#barMp'); if (mpBar){ mpBar.style.width = (P.mp.cur / P.mp.max * 100) + '%'; }
  var mpTxt = qs('#txtMp'); if (mpTxt){ mpTxt.textContent = P.mp.cur + '/' + P.mp.max; }
}



function buildMapUI(){
  const bigCol   = qs('#bigMapCol');
  const smallCol = qs('#smallMapCol');
  bigCol.innerHTML=''; smallCol.innerHTML='';

  // 左列：大地圖（清單＋建議等級）
  MAPS.forEach(m=>{
    const btn = document.createElement('div');
    btn.className = 'tag' + (m.id===curBig?' active':'');
    btn.innerHTML = `<span class="name">${m.name}</span><span class="lv">建議 ${m.lv||'—'}</span>`;
    btn.onclick = ()=>{
      curBig = m.id;
      curSmall = null;      // 切換大地圖時清空副地圖選擇
      entered = false;      // 必須重新進入
      buildMapUI();
      setLocBadge();
      updateActionPanel();
    };
    bigCol.appendChild(btn);
  });

  // 若尚未選擇，預設選第一個大地圖
  const big = MAPS.find(x=>x.id===curBig) || MAPS[0];
  if(!curBig && big){ curBig = big.id; }

  // 右列：依目前大地圖顯示副地圖（清單＋建議等級）
  (big?.small||[]).forEach(s=>{
    const btn = document.createElement('div');
    btn.className = 'tag' + (s.id===curSmall?' active':'');
    btn.innerHTML = `<span class="name">${s.name}</span><span class="lv">建議 ${s.lv||'—'}</span>`;
    btn.onclick = ()=>{
      curSmall = s.id;
      entered = false;    // 選了副地圖後，仍需按「進入」
      setLocBadge();
      updateActionPanel();

      // 標記 active
      Array.prototype.slice.call(smallCol.children).forEach(function(x){
      x.classList.remove('active');
    });
      btn.classList.add('active');

      // 更新地區情報
      renderAreaInfo();
    };
    smallCol.appendChild(btn);
  });

  setLocBadge();
  updateActionPanel();
  renderAreaInfo(); // 初始也渲染一次
}

/* 固定欄位：地區情報 */
/* 固定欄位：地區情報（不用可選鏈/未宣告變數） */
function renderAreaInfo(){
  var box = qs('#infoMonsters');

  // 依 curBig / curSmall 找到目前的小地圖
  var big = null, s = null;
  for (var i=0;i<MAPS.length;i++){
    if (MAPS[i].id === curBig){ big = MAPS[i]; break; }
  }
  if (big && big.small){
    for (var j=0;j<big.small.length;j++){
      if (big.small[j].id === curSmall){ s = big.small[j]; break; }
    }
  }
  if (!s){
    box.innerHTML = '<span class="chip">—</span>';
    return;
  }

  var chips = [];
  var list = s.monsters || [];
  for (var k=0;k<list.length;k++){
    var id = list[k];
    var m = (window.MonsterDB && MonsterDB.get) ? MonsterDB.get(id) : null;
    if(!m){
      chips.push('<span class="chip"><span class="mname">'+id+'</span></span>');
    }else{
      var el = (window.ELEMENT_LABEL && ELEMENT_LABEL[m.element]) || '無';
      chips.push(
        '<span class="chip">' +
          '<span class="pill elem '+(m.element||'none')+'">'+ el +'</span>' +
          '<span class="mname">'+ m.name +'</span><span class="mlv">LV.'+(m.level||1)+'</span>' +
        '</span>'
      );
    }
  }

  if (s.boss){
    var b = (window.MonsterDB && MonsterDB.get) ? MonsterDB.get(s.boss) : null;
    if (b){
      var elb = (window.ELEMENT_LABEL && ELEMENT_LABEL[b.element]) || '無';
      chips.push(
        '<span class="chip" style="border-color:#dc2626;background:rgba(220,38,38,.12)">' +
          '<strong>BOSS</strong>' +
          '<span class="pill elem '+(b.element||'none')+'">'+ elb +'</span>' +
          '<span class="mname">'+ b.name +'</span><span class="mlv">LV.'+(b.level||1)+'</span>' +
        '</span>'
      );
    }
  }

  box.innerHTML = chips.join('');
}


function setLocBadge(){
  const big = MAPS.find(x=>x.id===curBig);
  const small = big?.small?.find(x=>x.id===curSmall);
  const locTxt = small ? `目前位置：${big.name} ＞ ${small.name}` : '尚未選擇地點';
  qs('#locBadge').textContent = entered ? `${locTxt}（已進入）` : locTxt;
}



function updateBossUI(){
  const hint = qs('#slimeQuestHint');
  const btnBoss = qs('#btnBoss');
  if(!hint || !btnBoss) return;

  // 找到當前小地圖
  var big = null, area = null, i, j;
  for (i = 0; i < MAPS.length; i++){
    if (MAPS[i].id === curBig){ big = MAPS[i]; break; }
  }
  if (big && big.small){
    for (j = 0; j < big.small.length; j++){
      if (big.small[j].id === curSmall){ area = big.small[j]; break; }
    }
  }

  if(!area || !area.boss || !entered){
    hint.style.display = 'none';
    btnBoss.style.display = 'none';
    return;
  }

  P.mapProg = P.mapProg || {};
  var progKey = area.id;
  var prog = P.mapProg[progKey] || { kills:0, bossReady:false, bossDefeated:false };
  var requiredKills = area.killsRequired || 10;

  // ★ 修正：當擊殺數達標時，重新啟用 BOSS（不管之前是否擊敗過）
  if(prog.kills >= requiredKills){
    prog.bossReady = true;
    // 不重置 bossDefeated，保留歷史記錄
  }

  // 顯示邏輯：只要 bossReady 就能挑戰
  if(prog.bossReady){
    var statusPrefix = prog.bossDefeated ? '重新挑戰' : '首次挑戰';
    hint.textContent = `${area.name}：討伐已達 ${prog.kills}/${requiredKills} → 可以${statusPrefix} BOSS！`;
    hint.style.display = 'block';
    btnBoss.style.display = 'inline-block';
    btnBoss.textContent = statusPrefix + ' BOSS';
    btnBoss.style.background = '#b91c1c';
  }else{
    var statusText = prog.bossDefeated 
      ? `${area.name}：BOSS 已擊敗，需重新累積討伐進度 ${prog.kills}/${requiredKills}`
      : `${area.name}：怪物討伐進度 ${prog.kills}/${requiredKills}（達成後將出現 BOSS）`;
    
    hint.textContent = statusText;
    hint.style.display = 'block';
    btnBoss.style.display = 'none';
  }
}


function updateActionPanel(){
  const btnEnter   = qs('#btnEnter');
  const btnExplore = qs('#btnExplore');
  const btnFight   = qs('#btnFight');

  const canEnter = !!curBig && !!curSmall;
  btnEnter.disabled = !canEnter;

  if(!entered){
    btnEnter.style.display   = 'inline-block';
    btnExplore.style.display = 'none';
    btnFight.style.display   = 'none';
  }else{
    btnEnter.style.display   = 'none';
    btnExplore.style.display = 'inline-block';
    btnFight.style.display   = 'inline-block';
  }

  // ★ 同步更新 BOSS UI
  updateBossUI();
}

/* ===== 探險 ===== */
async function doExplore(){
  if(!curSmall){ log('請先選擇副地圖。'); return; }
  if(!entered){ log('請先按「進入」該地區。'); return; }

  var staCur = (P && P.sta && typeof P.sta.cur === 'number') ? P.sta.cur : 0;
  if(staCur < 2){ log('體力不足（需要 2）', 'warn'); return; }
  P.sta.cur = staCur - 2;

  var r = Math.random();
  if(r < 0.5){
    var got = 5 + Math.floor(Math.random()*16); // 5~20
    P.currencies.stone = (P.currencies.stone||0) + got;
    log('探險獲得 靈石 ×' + got, 'ok');
  }else if(r < 0.8){
    // 素材
    var picks = ['wood_shard','stone_core','ghost_essence'];
    var id = picks[Math.floor(Math.random()*picks.length)];
    var hasDef = (ItemDB && typeof ItemDB.getDef==='function' && ItemDB.getDef('materials', id));
    if(!hasDef){ id = 'wood_shard'; }
    var qty = 1 + Math.floor(Math.random()*2);
    if(ItemDB && typeof ItemDB.addMaterialToBag==='function') ItemDB.addMaterialToBag(P.bag, id, qty);
    var mdef = (ItemDB && ItemDB.getDef) ? ItemDB.getDef('materials', id) : null;
    var mname = (mdef && mdef.name) ? mdef.name : id;
    log('探險獲得素材：' + mname + ' ×' + qty, 'ok');
  }else{
    // 消耗品
    var ids = ['hp_small','mp_small'];
    var filtered = [];
    for (var i=0; i<ids.length; i++){
      var ok = (ItemDB && typeof ItemDB.getDef==='function' && ItemDB.getDef('consumables', ids[i]));
      if(ok) filtered.push(ids[i]);
    }
    var cid = filtered.length ? filtered[Math.floor(Math.random()*filtered.length)] : 'hp_small';
    if(ItemDB && typeof ItemDB.addConsumableToBag==='function') ItemDB.addConsumableToBag(P.bag, cid, 1);
    var cdef = (ItemDB && ItemDB.getDef) ? ItemDB.getDef('consumables', cid) : null;
    var cname = (cdef && cdef.name) ? cdef.name : cid;
    log('探險獲得丹藥：' + cname + ' ×1', 'ok');
  }

  refreshLive();
  renderHeader();
  renderBars();
  
  // ★ 探險後立即同步到 Auth 快取（加強版）
  if (window.Auth && Auth.setCharacter) {
    try { 
      var cleanData = JSON.parse(JSON.stringify(P));
      delete cleanData._live;
      Auth.setCharacter(cleanData); 
      console.log('🗺️ 探險後同步成功 - 體力:', P.sta.cur, '靈石:', P.currencies.stone);
    } catch(_e) {
      console.error('❌ 探險後同步失敗:', _e);
    }
  }
}


/* ===== 戰鬥（ATB） ===== */
const ATB_MAX = 1000;      // 滿格門檻
let battle = null;         // 戰鬥狀態
let loop = null;           // 計時器

function startBattle(){
  if(!curSmall){ log('請先選擇副地圖。'); return; }
  if(!entered){ log('請先按「進入」該地區。'); return; }

  // 找到目前區域
  var big = null, area = null, i, j;
  for (i = 0; i < MAPS.length; i++){
    if (MAPS[i].id === curBig){ big = MAPS[i]; break; }
  }
  if (big && big.small){
    for (j = 0; j < big.small.length; j++){
      if (big.small[j].id === curSmall){ area = big.small[j]; break; }
    }
  }
  if(!area){ log('找不到該地區'); return; }

  // 指定怪（BOSS）或隨機
  var enemy = null;
  if(window.FORCE_MONSTER_ID){
    var def = (window.MonsterDB && MonsterDB.DB) ? MonsterDB.DB[window.FORCE_MONSTER_ID] : null;
    if(def) enemy = JSON.parse(JSON.stringify(def));
    window.FORCE_MONSTER_ID = null;
  }
  if(!enemy){
    var pool = [];
    if (area.monsters && window.MonsterDB && MonsterDB.DB){
      for (i = 0; i < area.monsters.length; i++){
        var mid = area.monsters[i];
        var mdef = MonsterDB.DB[mid];
        if (mdef) pool.push(mdef);
      }
    }
    if(!pool.length){ log('此地尚無怪物資料'); return; }
    enemy = JSON.parse(JSON.stringify(pool[Math.floor(Math.random()*pool.length)]));
  }

  // 顯示戰鬥區
  qs('#mapSection').style.display = 'none';
  qs('#battleSection').classList.add('show');
  if (loop){ clearInterval(loop); loop = null; }

  // 玩家衍生值快照
  refreshLive();
  var d = (P && P._live) ? P._live : {};

  // 取怪物衍生表
  var dMon = null;
  try{
    if (window.MonsterDB && MonsterDB.getDerived){
      dMon = MonsterDB.getDerived(enemy.id) || null;
    }
  }catch(_err){ dMon = null; }

  function pickD(key, fallback){
    var v = (dMon && typeof dMon[key]==='number') ? dMon[key] : fallback;
    return (typeof v==='number') ? v : (fallback||0);
  }

  var eStats = {
    atk  : pickD('物理攻擊',   10),
    matk : pickD('法術攻擊',   10),
    def  : pickD('物理防禦',    8),
    mdef : pickD('法術防禦',    8),
    acc  : pickD('命中率',     75),
    eva  : pickD('閃避',        5),
    crit : Math.min(100, pickD('暴擊率', 3)),
    aspd : Math.max(0.5, pickD('行動條速度', 100) / 100),
    pen  : pickD('破甲',        0)
  };

  battle = {
    enemy: enemy,
    enemyStats: eStats,
    p:{
      hp   : (P && P.hp && typeof P.hp.cur==='number') ? P.hp.cur : 100,
      hpMax: (P && P.hp && typeof P.hp.max==='number') ? P.hp.max : 100,
      mp   : (P && P.mp && typeof P.mp.cur==='number') ? P.mp.cur : 0,
      mpMax: (P && P.mp && typeof P.mp.max==='number') ? P.mp.max : 0,
      atb  : 0,
      // 直接吃行動條速度（0~任意），不要保底；比例化步幅會在人性化演算法中處理
      speed: (d && typeof d['行動條速度']==='number') ? d['行動條速度'] : 100
    },
    e:{
      hp   : pickD('氣血上限', 100),
      hpMax: pickD('氣血上限', 100),
      atb  : 0,
      // 直接吃行動條速度（0~任意）
      speed: pickD('行動條速度', 100)
    },
    turn:'none',
    over:false
  };



  qs('#eName').textContent = enemy.name;
  qs('#eLv').textContent = enemy.level;
  qs('#pLv').textContent = P.level;

  var getElemLabel = function(k){ return (ELEMENT_LABEL && ELEMENT_LABEL[k]) ? ELEMENT_LABEL[k] : k; };
  var pElem = (P && (P.element || P.elem)) ? (P.element || P.elem) : 'none';
  var eElem = (enemy && (enemy.element || enemy.elem)) ? (enemy.element || enemy.elem) : 'none';

  var pEl = qs('#pElem'), eEl = qs('#eElem');
  if (pEl) { pEl.textContent = getElemLabel(pElem); pEl.className = 'pill elem ' + pElem; }
  if (eEl) { eEl.textContent = getElemLabel(eElem); eEl.className = 'pill elem ' + eElem; }

  log('元素資訊｜你：' + getElemLabel(pElem) + '　敵人：' + getElemLabel(eElem));

  var pImg = qs('#pImg'); var eImg = qs('#eImg');
  // 優先使用外觀圖示，沒有外觀時才回退到頭像/預設
  var pSrc = (P && P.equip && P.equip.character && P.equip.character.icon && String(P.equip.character.icon).trim())
    ? P.equip.character.icon
    : ((P && P.avatar && typeof P.avatar==='string' && P.avatar.trim()) ? P.avatar : PLAYER_IMG_URL);
  var pic = (window.MonsterDB && MonsterDB.getImage) ? MonsterDB.getImage(enemy.id) : {url:'',mirror:false};

  if (pImg) { pImg.src = pSrc; }


  if (eImg){
    // ★ 開戰先完整重置敵人立繪狀態（避免上一場的 0 透明度/動畫殘留）
    eImg.style.opacity = '1';
    eImg.style.transition = '';
    eImg.classList.remove('fade-out');
    // 清掉上一場特效殘留
    var eFx = qs('#eFx'); if (eFx) eFx.innerHTML = '';
    var pFx = qs('#pFx'); if (pFx) pFx.innerHTML = '';

    // 設置圖片與鏡像
    var finalUrl = (pic && typeof pic.url==='string' && pic.url.trim()) ? pic.url : 'https://picsum.photos/seed/monster/500/500';
    eImg.classList.toggle('mirror', !!(pic && pic.mirror));

    // 安全預載：失敗時回退預設圖，避免空黑畫面
    var test = new Image();
    test.onload = function(){
      if (test.naturalWidth > 0 && test.naturalHeight > 0){
        eImg.src = finalUrl;
      }else{
        eImg.src = 'https://picsum.photos/seed/monster/500/500';
      }
    };
    test.onerror = function(){
      eImg.src = 'https://picsum.photos/seed/monster/500/500';
    };
    test.src = finalUrl;

    /* ★★★ 這裡關鍵：每一場戰鬥都重新觸發翻轉動畫 ★★★ */
    var eFrame = document.querySelector('.e-frame');
    if (eFrame){
      // 移除舊動畫 → 強制回流 → 再加回去，確保每次都會播放
      eFrame.classList.remove('flip-in');
      void eFrame.offsetWidth;  // 強制回流（不要刪）
      eFrame.classList.add('flip-in');
    }
  }

  updateBattleBars();
  updateCmdEnabled();
  log('在 ' + (area.name||'當前地區') + ' 遭遇 ' + enemy.name + '！');
  loop = setInterval(tickATB, 60);
}


function tickATB(){
  if(!battle || battle.over) return;
  if (battle.p.atb >= ATB_MAX) {
    updateCmdEnabled();
    updateBattleBars();
    return;
  }

  // —— 人性化比例：以雙方最大速度當基準做映射（確保差距可見但不離譜）
  var spP = (typeof battle.p.speed==='number') ? battle.p.speed : 100;
  var spE = (typeof battle.e.speed==='number') ? battle.e.speed : 100;
  if (spP < 0) spP = 0;
  if (spE < 0) spE = 0;
  var spMax = Math.max(spP, spE, 1);  // 避免除 0

  // 可微調的人性化步幅區間
  var MIN_STEP = 2;   // 每 tick 最少+2（讓非常慢的一方還是能動）
  var MAX_STEP = 24;  // 每 tick 最多+24（非常快的一方）

  function mapStep(sp){
    var ratio = sp / spMax;                   // 0~1
    var step  = Math.round(MIN_STEP + ratio * (MAX_STEP - MIN_STEP));
    if (step < 1) step = 1;                   // 再保一層不會 0
    return step;
  }

  var pStep = mapStep(spP);
  var eStep = mapStep(spE);

  battle.p.atb = clamp(battle.p.atb + pStep, 0, ATB_MAX);
  battle.e.atb = clamp(battle.e.atb + eStep, 0, ATB_MAX);

  updateBattleBars();
  updateCmdEnabled();

  if (battle.e.atb >= ATB_MAX){
    enemyAttack();
    battle.e.atb = 0;
    updateBattleBars();
  }
}



function updateBattleBars(){
  qs('#pHp').style.width  = pct(battle.p.hp, battle.p.hpMax) + '%';
  qs('#eHp').style.width  = pct(battle.e.hp, battle.e.hpMax) + '%';
  qs('#pATB').style.width = pct(battle.p.atb, ATB_MAX) + '%';
  qs('#eATB').style.width = pct(battle.e.atb, ATB_MAX) + '%';
  qs('#btState').textContent = battle.over ? '戰鬥結束' : (battle.p.atb>=ATB_MAX?'輪到你行動':'等待行動條…');

  if(P && P.hp){
    P.hp.cur = battle.p.hp;
    P.hp.max = battle.p.hpMax;
  }
  if(P && P.mp){
    P.mp.cur = battle.p.mp || P.mp.cur || 0;
    P.mp.max = battle.p.mpMax || P.mp.max || 0;
  }
  renderBars();
}

// 受擊浮字 / 閃光 / 抖動
function spawnFloat(side, value, type){
  type = type || 'dmg';
  var host = (side==='player') ? qs('#pFx') : qs('#eFx');
  if(!host) return;
  var el = document.createElement('div');
  if (type==='miss'){
    el.className = 'dmg-float';
    el.textContent = 'MISS';
  }else{
    el.className = 'dmg-float ' + (type==='heal'?'heal':(type==='crit'?'crit dmg':'dmg'));
    el.textContent = (type==='heal' ? '+' : '-') + value;
  }
  host.appendChild(el);
  setTimeout(function(){ el.remove(); }, 1000);
}
function flashShake(side){
  var img = (side==='player') ? qs('#pImg') : qs('#eImg');
  var fx  = (side==='player') ? qs('#pFx') : qs('#eFx');
  if(!img || !fx) return;
  var f = document.createElement('div');
  f.className = 'flash';
  fx.appendChild(f);
  setTimeout(function(){ f.remove(); }, 260);
  img.classList.add('shake');
  setTimeout(function(){ img.classList.remove('shake'); }, 520);
}
function showHit(side, amount, isCrit, kind){
  if(kind==='heal'){
    spawnFloat(side, amount, 'heal');
    return;
  }
  spawnFloat(side, amount, isCrit?'crit':'dmg');
  flashShake(side);
}

function updateCmdEnabled(){
  var canAct = battle && !battle.over && battle.p.atb>=ATB_MAX;
  ['actAttack','actSkill','actItem','actRun'].forEach(function(id){ qs('#'+id).disabled = !canAct; });
}

function calcDamage(isPlayer){
  function clamp01(x,min,max){ return Math.max(min, Math.min(max, x)); }
  function hitChanceOf(attAcc, defEva, base){ base = (typeof base==='number')?base:75; return clamp01(base + (attAcc|0) - (defEva|0), 5, 98); }

  if(isPlayer){
    if (!P._live) refreshLive();
    var D = P._live;

    var attAcc = D['命中率'] || 0;
    var defEva = (battle.enemyStats && battle.enemyStats.eva) ? battle.enemyStats.eva : 0;
    var hitChance = hitChanceOf(attAcc, defEva, 75);
    if (Math.random()*100 >= hitChance){
      var atkElem0 = (P && (P.element||P.elem)) ? (P.element||P.elem) : 'none';
      var defElem0 = (battle.enemy && (battle.enemy.element||battle.enemy.elem)) ? (battle.enemy.element||battle.enemy.elem) : 'none';
      return { dmg:0, miss:true, crit:false, note:'', elemMul:1, stabMul:1, atkElem:atkElem0, defElem:defElem0, hitChance:hitChance };
    }

    var atk = D['物理攻擊']||0;
    var pen = D['破甲']||0;
    var critRate = D['暴擊率']||0;
    var critDmg  = (100 + (D['暴擊傷害']||50)) / 100;
    var eDef = Math.max(0, ((battle.enemyStats && battle.enemyStats.def) ? battle.enemyStats.def : 0) - pen);
    var base = Math.max(1, atk - eDef);
    base = Math.round(base * (0.9 + Math.random()*0.2));
    var isCrit = Math.random()*100 < critRate;
    var out = Math.max(1, Math.round(base * (isCrit ? critDmg : 1)));

    var atkElem = (P && (P.element||P.elem)) ? (P.element||P.elem) : 'none';
    var defElem = (battle.enemy && (battle.enemy.element||battle.enemy.elem)) ? (battle.enemy.element||battle.enemy.elem) : 'none';
    var elemMul = elemMult(atkElem, defElem);
    var stabMul = (atkElem!=='none') ? (window.STAB||1) : 1;
    out = Math.max(1, Math.round(out * elemMul * stabMul));

    return { dmg: out, miss:false, crit:isCrit, note:'', elemMul:elemMul, stabMul:stabMul, atkElem:atkElem, defElem:defElem, hitChance:hitChance };
  }else{
    var eS = battle.enemyStats || {};
    if (!P._live) refreshLive();
    var attAcc2 = eS.acc || 0;
    var defEva2 = P._live['閃避'] || 0;
    var hitChance2 = hitChanceOf(attAcc2, defEva2, 75);
    if (Math.random()*100 >= hitChance2){
      var atkElem1 = (battle.enemy && (battle.enemy.element||battle.enemy.elem)) ? (battle.enemy.element||battle.enemy.elem) : 'none';
      var defElem1 = (P && (P.element||P.elem)) ? (P.element||P.elem) : 'none';
      return { dmg:0, miss:true, crit:false, note:'', elemMul:1, stabMul:1, atkElem:atkElem1, defElem:defElem1, hitChance:hitChance2 };
    }
    var atk2 = Math.max(1, eS.atk || 8);
    var pen2 = Math.max(0, eS.pen || 0);
    var pDef0  = Math.max(0, (P._live['物理防禦']||0));
    var effDef = Math.max(0, pDef0 - pen2);
    var base2 = Math.max(1, atk2 - effDef);
    base2 = Math.round(base2 * (0.9 + Math.random()*0.2));
    var out2 = Math.max(1, Math.round(base2));

    var atkElem2 = (battle.enemy && (battle.enemy.element||battle.enemy.elem)) ? (battle.enemy.element||battle.enemy.elem) : 'none';
    var defElem2 = (P && (P.element||P.elem)) ? (P.element||P.elem) : 'none';
    var elemMul2 = elemMult(atkElem2, defElem2);
    var stabMul2 = (atkElem2!=='none') ? (window.STAB||1) : 1;
    out2 = Math.max(1, Math.round(out2 * elemMul2 * stabMul2));

    return { dmg: out2, miss:false, crit:false, note:'', elemMul:elemMul2, stabMul:stabMul2, atkElem:atkElem2, defElem:defElem2, hitChance:hitChance2 };
  }
}

function playerAttack(){
  var r = calcDamage(true);
  if (r.miss){
    spawnFloat('enemy', 0, 'miss');
    log('你攻擊落空！（命中機率 ' + Math.round(r.hitChance) + '%）', 'warn');
  }else{
    battle.e.hp = clamp(battle.e.hp - r.dmg, 0, battle.e.hpMax);
    showHit('enemy', r.dmg, !!r.crit, 'hit');
    var rel = elemRelationText(r.atkElem, r.defElem, r.elemMul, r.stabMul);
    log('你對 ' + battle.enemy.name + ' 造成 ' + r.dmg + ' 傷害' + (r.crit?'（暴擊）':'') + ' ' + rel);
  }
  battle.p.atb = 0;
  endCheck();
  updateBattleBars(); updateCmdEnabled();
  if(!battle.over && battle.e.atb>=ATB_MAX){ enemyAttack(); battle.e.atb=0; updateBattleBars(); }
}

function enemyAttack(){
  var E = battle.enemy || {};
  var skills = E.skills || [];
  if (skills.length){
    var s = skills[0];
    var hpRate = Math.max(0, battle.e.hp) / Math.max(1, battle.e.hpMax);
    var useChance = (typeof s.chance==='number'?s.chance:0) + ((hpRate < 0.5) ? (typeof s.lowHpBonus==='number'?s.lowHpBonus:0) : 0);
    if (Math.random() < useChance){
      // 🌟 添加技能預告訊息
      log('💀 ' + E.name + ' 準備施放「' + s.name + '」！', 'warn');
      
      // ★ 敵人技能橫幅效果（與玩家相同）
      if (typeof showSkillBanner === 'function') {
        showSkillBanner('敵人施放：' + s.name, s.elem);
      }
      
      var damage;
      if (s.kind === 'physical') {
        damage = calcPhysicalDamageFromEnemy(s.elem || 'none', s.power || 100);
        showHit('player', damage.dmg, false, 'hit');
        var rel2 = elemRelationText(damage.atkElem, damage.defElem, damage.elemMul, damage.stabMul);
        log(E.name + ' 施放「' + s.name + '」，對你造成 ' + damage.dmg + ' 物理傷害 ' + rel2);
      } else {
        damage = calcMagicDamageFromEnemy(s.elem || 'none', s.power || 100);
        showHit('player', damage.dmg, false, 'hit');
        var rel2 = elemRelationText(damage.atkElem, damage.defElem, damage.elemMul, damage.stabMul);
        log(E.name + ' 施放「' + s.name + '」，對你造成 ' + damage.dmg + ' 法術傷害 ' + rel2);
      }
      battle.p.hp = clamp(battle.p.hp - damage.dmg, 0, battle.p.hpMax);
      applyDotToPlayer(s.dps|0, s.duration|0, s.name);
      endCheck();
      updateBattleBars();
      return;
    }

  }
  var r = calcDamage(false);
  if (r.miss){
    spawnFloat('player', 0, 'miss');
    log(E.name + ' 的攻擊落空！（命中機率 ' + Math.round(r.hitChance) + '%）', 'warn');
  }else{
    battle.p.hp = clamp(battle.p.hp - r.dmg, 0, battle.p.hpMax);
    showHit('player', r.dmg, false, 'hit');
    var rel = elemRelationText(r.atkElem, r.defElem, r.elemMul, r.stabMul);
    log(E.name + ' 對你造成 ' + r.dmg + ' 傷害 ' + rel);
  }
  endCheck();
  updateBattleBars();
}


// ★ 新增：敵人物理技能傷害計算
function calcPhysicalDamageFromEnemy(atkElem, power){
  atkElem = atkElem || 'none';
  power = power || 100;
  var eS = battle.enemyStats || {};
  var atk = Math.max(1, eS.atk || 8);
  var pen = Math.max(0, eS.pen || 0);
  if (!P._live) refreshLive();
  var pDef0  = Math.max(0, (P._live['物理防禦']||0));
  var effDef = Math.max(0, pDef0 - pen);
  
  // 套用技能威力
  var base = Math.max(1, (atk * power / 100) - effDef);
  base = Math.round(base * (0.9 + Math.random()*0.2));
  var out = Math.max(1, Math.round(base));
  
  var defElem = (P && (P.element||P.elem)) ? (P.element||P.elem) : 'none';
  var elemMul = elemMult(atkElem, defElem);
  var stabMul = (atkElem!=='none') ? (window.STAB||1) : 1;
  out = Math.max(1, Math.round(out * elemMul * stabMul));
  return { dmg: out, atkElem:atkElem, defElem:defElem, elemMul:elemMul, stabMul:stabMul };
}

function calcMagicDamageFromEnemy(atkElem, power){
  atkElem = atkElem || 'none';
  power = power || 100;
  var eS = battle.enemyStats || {};
  var matk = Math.max(1, eS.matk || 8);
  var mpen = Math.max(0, eS.mpen || 0);
  if (!P._live) refreshLive();
  var pMdef0  = Math.max(0, (P._live['法術防禦']||0));
  var effMdef = Math.max(0, pMdef0 - mpen);
  
  // 套用技能威力
  var base = Math.max(1, (matk * power / 100) - effMdef);
  base = Math.round(base * (0.9 + Math.random()*0.2));
  var out = Math.max(1, Math.round(base));
  
  var defElem = (P && (P.element||P.elem)) ? (P.element||P.elem) : 'none';
  var elemMul = elemMult(atkElem, defElem);
  var stabMul = (atkElem!=='none') ? (window.STAB||1) : 1;
  out = Math.max(1, Math.round(out * elemMul * stabMul));
  return { dmg: out, atkElem:atkElem, defElem:defElem, elemMul:elemMul, stabMul:stabMul };
}


function applyDotToPlayer(dps, seconds, label){
  dps = dps|0; seconds = seconds|0; label = label || '持續傷害';
  if(!battle.dotTimers) battle.dotTimers = [];
  var t = 0;
  var timer = setInterval(function(){
    if(!battle || battle.over){ clearInterval(timer); return; }
    if(battle.p.hp<=0 || battle.e.hp<=0){ clearInterval(timer); return; }
    t++;
    battle.p.hp = clamp(battle.p.hp - Math.max(0,dps), 0, battle.p.hpMax);
    showHit('player', Math.max(0,dps), false, 'hit');
    log('【持續傷害】' + label + '：-' + dps + '（' + t + '/' + seconds + '）', 'warn');
    updateBattleBars();
    endCheck();
    if(t>=seconds) clearInterval(timer);
  }, 1000);
  battle.dotTimers.push(timer);
}

function useItem(){
  var bag = P.bag || {};
  var list = (bag.consumables || []).filter(function(x){ return x && x.count>0; });
  if(!list.length){
    log('沒有可用的消耗品','warn');
    return;
  }
  var menu = document.createElement('div');
  menu.style.position='fixed';
  menu.style.inset='0';
  menu.style.background='rgba(0,0,0,0.6)';
  menu.style.zIndex='9999';
  menu.style.display='grid';
  menu.style.placeItems='center';

  var box = document.createElement('div');
  box.style.background='#1e293b';
  box.style.padding='12px';
  box.style.borderRadius='12px';
  box.style.maxWidth='300px';
  box.style.display='grid';
  box.style.gap='8px';

  var title = document.createElement('div');
  title.textContent = '選擇要使用的消耗品';
  title.style.fontWeight='700';
  title.style.marginBottom='6px';
  box.appendChild(title);

  list.forEach(function(it){
    var btn = document.createElement('button');
    btn.style.display='flex';
    btn.style.alignItems='center';
    btn.style.gap='6px';
    btn.style.padding='6px 8px';
    btn.style.borderRadius='8px';
    btn.style.background='rgba(255,255,255,0.08)';
    btn.style.color='#fff';
    btn.style.border='1px solid rgba(255,255,255,0.15)';
    btn.style.cursor='pointer';

    var img = document.createElement('img');
    img.src = it.icon || '';
    img.style.width='28px';
    img.style.height='28px';
    img.style.objectFit='cover';
    img.style.borderRadius='6px';

    var txt = document.createElement('div');
    txt.innerHTML = '<b>' + it.name + '</b> ×' + it.count + '<br/><small>' + (it.effect && it.effect.hp ? ('回復HP ' + it.effect.hp) : '') + (it.effect && it.effect.mp ? (' 回復MP ' + it.effect.mp) : '') + '</small>';

    btn.appendChild(img);
    btn.appendChild(txt);

    btn.onclick = function(){
      it.count--; if(it.count<=0) bag.consumables = (bag.consumables||[]).filter(function(x){ return x.count>0; });
      if(it.effect && typeof it.effect.hp==='number'){
        var heal = it.effect.hp;
        battle.p.hp = clamp(battle.p.hp + heal, 0, battle.p.hpMax);
        if (P && P.hp) P.hp.cur = battle.p.hp;
        showHit('player', heal, false, 'heal');
        log('使用 ' + it.name + ' 回復 ' + heal + ' 氣血。');
      }
      if(it.effect && typeof it.effect.mp==='number'){
        var heal2 = it.effect.mp;
        battle.p.mp = clamp((battle.p.mp||0) + heal2, 0, battle.p.mpMax);
        if (P && P.mp) P.mp.cur = battle.p.mp;
        showHit('player', heal2, false, 'heal');
        log('使用 ' + it.name + ' 回復 ' + heal2 + ' 真元。');
      }
      battle.p.atb = 0;
      renderBars();
    // ★ 使用道具後立即同步到 Auth 快取
    if (window.Auth && Auth.setCharacter) {
      try { 
        var cleanData = JSON.parse(JSON.stringify(P));
        delete cleanData._live;
        Auth.setCharacter(cleanData); 
      } catch(_) {}
    }
      savePlayer();
      updateBattleBars(); updateCmdEnabled();
      menu.remove();
    };

    box.appendChild(btn);
  });

  var cancel = document.createElement('button');
  cancel.textContent='取消';
  cancel.style.marginTop='6px';
  cancel.onclick=function(){ menu.remove(); };
  box.appendChild(cancel);

  menu.appendChild(box);
  document.body.appendChild(menu);
}

function tryRun(){
  var ok = Math.random()<0.6;
  if(ok){
    log('成功脫離戰鬥。','ok');
    finishBattle(false);
  }else{
    log('逃跑失敗！','warn');
    battle.p.atb = 0;
    updateCmdEnabled();
  }
}

async function endCheck(){
  if(!battle || battle.over) return;

  if(battle.e.hp<=0){
    log('你打倒了 ' + (battle.e.name||'敵人') + '！','ok');

    // 1) 停止敵方行動、淡出（不再跑 ATB）
    finishBattle();
    var eImg = document.getElementById('eImg');
    if(eImg){ eImg.classList.add('fade-out'); }


    try{
      // 找當前的小地圖
      var big=null, area=null, i,j;
      for(i=0;i<MAPS.length;i++){ if(MAPS[i].id===curBig){ big=MAPS[i]; break; } }
      if(big && big.small){
        for(j=0;j<big.small.length;j++){ if(big.small[j].id===curSmall){ area=big.small[j]; break; } }
      }
      
      // ★ 通用多地圖處理
      if(area && area.boss){
        P.mapProg = P.mapProg || {};
        var progKey = area.id;
        var prog = P.mapProg[progKey] || { kills:0, bossReady:false, bossDefeated:false };
        
        // 取得該地圖需要的擊殺數（預設 10）
        var requiredKills = area.killsRequired || 10;
        
        // 檢查是否為 BOSS 戰
        var isBossKill = (battle.enemy && battle.enemy.id === area.boss);
        
        if(isBossKill){
          // ★ BOSS 被擊敗 - 重置進度，需重新累積
          prog.bossDefeated = true;
          prog.bossReady = false;    // ← 關鍵：重置為 false
          prog.kills = 0;            // ← 關鍵：重置擊殺數
          log('🎉 恭喜！你擊敗了 ' + area.name + ' 的 BOSS！需重新累積討伐進度才能再次挑戰。', 'ok');
          
        }else if(!prog.bossReady){

          // ★ 一般怪物，累積擊殺數
          prog.kills = (prog.kills|0) + 1;
          
          if(prog.kills >= requiredKills){
            prog.kills = requiredKills;    // 封頂
            prog.bossReady = true;
            log(area.name + ' BOSS 已出現！可以挑戰了！','ok');
          }else{
            log(area.name + ' 討伐進度：' + prog.kills + '/' + requiredKills);
          }
        }
        
        // 儲存進度
        P.mapProg[progKey] = prog;
        
        // 更新 UI
        if(typeof updateBossUI === 'function') updateBossUI();
      }
    }catch(_e){
      console.error('地圖進度更新錯誤:', _e);
    }

    // 2) 掉落（MonsterDB）
    (function resolveDrops(monId){
      try{
        var loots = (window.MonsterDB && typeof MonsterDB.rollDrops==='function') ? MonsterDB.rollDrops(monId) : [];
        if(!loots || !loots.length){
          log('戰利品：—');
        }else{
          if(window.MonsterDB && typeof MonsterDB.applyDrops==='function'){ MonsterDB.applyDrops(P, loots); }
          var txt = [];
          for (var i=0;i<loots.length;i++){
            var it = loots[i]||{};
            var shown = it.name || it.id || '';
            if(!shown){
              if (it.type==='material' && window.ItemDB && ItemDB.getDef){
                var mdef = ItemDB.getDef('materials', it.id); if(mdef && mdef.name) shown = mdef.name;
              }else if (it.type==='consumable' && window.ItemDB && ItemDB.getDef){
                var cdef = ItemDB.getDef('consumables', it.id); if(cdef && cdef.name) shown = cdef.name;
              }
            }
            if(it.type==='currency' && it.id==='stone') shown = '靈石';
            if(it.type==='currency' && it.id==='diamond') shown = '鑽石';
            var amount = it.amount|0;
            if(amount>0) txt.push(shown + ' ×' + amount);
          }
          log('戰利品：' + (txt.length ? txt.join('；') : '—'), txt.length ? 'ok' : undefined);
        }
      }catch(_e){}
    })((battle.enemy && battle.enemy.id) ? battle.enemy.id : battle.enemy);

    // 3) 經驗與升級（保留溢出）
    var baseExp = 10 + ((battle.enemy && battle.enemy.level) || 1) * 4;
    var expGain = baseExp;
    var bonusExp = 0;
    
    try{
      if (window.MonsterDB && typeof MonsterDB.expFor === 'function') {
        // 用真正的怪物（或其 id）來計算，才有正確等級/Rank/xpBonus
        var monForExp = (battle.enemy && battle.enemy.id) ? battle.enemy.id : battle.enemy;
        expGain = MonsterDB.expFor(monForExp, (P && typeof P.level==='number') ? P.level : null);
        bonusExp = expGain - baseExp;
      }
    }catch(_){}


    
    if (!P.exp) P.exp = {cur:0, max:100};
    if (typeof P.exp.cur!=='number') P.exp.cur = 0;
    if (typeof P.exp.max!=='number' || P.exp.max<=0) P.exp.max = 100;
    P.exp.cur = (P.exp.cur|0) + (expGain|0);
    
    // ★分開顯示基礎經驗和額外經驗
    if (bonusExp > 0) {
      log('獲得經驗：' + baseExp + ' + ' + bonusExp + ' = ' + expGain + '（含額外加成）', 'ok');
    } else if (bonusExp < 0) {
      log('獲得經驗：' + baseExp + ' - ' + Math.abs(bonusExp) + ' = ' + expGain + '（等級差距減少）', 'ok');
    } else {
      log('獲得經驗：' + expGain, 'ok');
    }


    // ★ 每升一級 +2 基礎屬性點（unspentPoints）
    var leveled = 0;
    while (P.exp.cur >= P.exp.max){
      P.exp.cur = P.exp.cur - P.exp.max;
      P.level = (P.level|0) + 1;
      P.exp.max = Math.max(50, Math.round((P.exp.max||100) * 1.25));
      leveled = leveled + 1;
    }
    if (leveled>0){
      if (typeof P.unspentPoints!=='number') P.unspentPoints = 0;
      P.unspentPoints = P.unspentPoints + (leveled * 2);
      log('升到 ' + P.level + ' 級！獲得屬性點 +' + (leveled*2) + '（可到主城分配）','ok');
      refreshLive();
      renderHeader();
      renderBars();
      if(battle && !battle.over){
        var newHpMax = P._live['氣血上限'] || P.hp.max;
        var newMpMax = P._live['真元上限'] || P.mp.max;
        battle.p.hpMax = newHpMax;
        battle.p.mpMax = newMpMax;
        P.hp.max = newHpMax;
        P.mp.max = newMpMax;
        updateBattleBars();
      }
      // ★ 關鍵：升級後立即同步到 Auth 快取（加強版）
      if (window.Auth && Auth.setCharacter) {
        try { 
          var cleanData = JSON.parse(JSON.stringify(P));
          delete cleanData._live;
          Auth.setCharacter(cleanData); 
          console.log('🎉 升級後同步成功 - 等級:', P.level, '經驗:', P.exp.cur + '/' + P.exp.max);
        } catch(_e) {
          console.error('❌ 升級後同步失敗:', _e);
        }
      }
    }


    renderHeader();
    renderBars();
    
    // ★ 戰鬥結束後立即同步到 Auth 快取（加強版）
    if (window.Auth && Auth.setCharacter) {
      try { 
        var cleanData = JSON.parse(JSON.stringify(P));
        delete cleanData._live;
        Auth.setCharacter(cleanData); 
        console.log('⚔️ 戰鬥結束後同步成功 - 等級:', P.level, '氣血:', P.hp.cur + '/' + P.hp.max);
      } catch(_e) {
        console.error('❌ 戰鬥結束後同步失敗:', _e);
      }
    }
    // ★ 修正：戰鬥結束存檔前先清理 _live
    var tempLive = P._live;  // 暫存 _live
    delete P._live;          // 移除 _live
    try{ await savePlayer(); }catch(_){}
    P._live = tempLive;      // 恢復 _live（供後續使用）


    setTimeout(function(){ leaveBattle(); }, 1200);
    }else if(battle.p.hp<=0){
    log('你被擊倒了…（保留 1 點氣血）', 'warn');
    battle.p.hp = 1;
    if (P && P.hp) {
      P.hp.cur = 1;
      P.hp.max = battle.p.hpMax || P.hp.max;
    }
    renderBars();
    
    // ★ 戰鬥結束後立即同步到 Auth 快取（加強版）
    if (window.Auth && Auth.setCharacter) {
      try { 
        var cleanData = JSON.parse(JSON.stringify(P));
        delete cleanData._live;
        Auth.setCharacter(cleanData); 
        console.log('⚔️ 戰鬥結束後同步成功 - 等級:', P.level, '氣血:', P.hp.cur + '/' + P.hp.max);
      } catch(_e) {
        console.error('❌ 戰鬥結束後同步失敗:', _e);
      }
    }

    // ★ 修正：戰鬥結束存檔前先清理 _live
    var tempLive2 = P._live;  // 暫存 _live
    delete P._live;           // 移除 _live
    try{ await savePlayer(); }catch(_){}
    P._live = tempLive2;      // 恢復 _live（供後續使用）


    setTimeout(function(){ leaveBattle(); }, 1200);
  }
}


function finishBattle(){
  battle.over = true;
  if(loop){ clearInterval(loop); loop=null; }
  if(battle && Array.isArray(battle.dotTimers)){
    for(var i=0;i<battle.dotTimers.length;i++){ try{ clearInterval(battle.dotTimers[i]); }catch(e){} }
    battle.dotTimers.length = 0;
  }
  updateBattleBars(); updateCmdEnabled();
  qs('#btnLeaveBattle').style.display='none';
}

function leaveBattle(){
  qs('#battleSection').classList.remove('show');
  qs('#btnLeaveBattle').style.display='none';
  qs('#mapSection').style.display='grid';
  battle=null;
}

/* ===== Log（同步寫入地圖＆戰鬥兩邊） ===== */
function log(t, cls){
  const targets = [ qs('#logMap'), qs('#logBattle') ].filter(Boolean);
  for(const box of targets){
    const el = document.createElement('div');
    el.textContent = t;
    if (cls) el.classList.add(cls);
    box.appendChild(el);
    // ★ 若行數過多，刪除最舊的，以免日誌過長
    while(box.childElementCount > 60){ box.removeChild(box.firstChild); }
    box.scrollTop = 1e9;
  }
}


/* ===== 事件 ===== */
qs('#btnBackHome').onclick = async function(){
  try{ if (P) { await savePlayer(); } }catch(e){}
  location.href = 'game.html';
};

/* ★ 新增：頁面離開/隱藏時也強制存檔，避免沒點到「回主城」導致沒存到 */
addEventListener('pagehide', function(){
  try { 
    if (P && window.Auth && Auth.saveCharacter) { 
      var cleanData = JSON.parse(JSON.stringify(P));
      delete cleanData._live;
      Auth.saveCharacter(cleanData); 
    } 
  } catch(_){}
});
addEventListener('visibilitychange', function(){
  try { 
    if (document.visibilityState === 'hidden' && P && window.Auth && Auth.saveCharacter) { 
      var cleanData = JSON.parse(JSON.stringify(P));
      delete cleanData._live;
      Auth.saveCharacter(cleanData); 
    } 
  } catch(_){}
});


qs('#btnLogout').onclick = ()=>{ if(window.Auth && Auth.logout) Auth.logout(); location.href='index.html'; };

  qs('#btnEnter').onclick = ()=>{
    if(!curSmall){ log('請先選擇副地圖。'); return; }
    entered = true;
    refreshLive();
    setLocBadge();
    updateActionPanel();
    log('已進入當前區域，可以進行「探險 / 戰鬥」。','ok');
  };

  qs('#btnExplore').onclick = doExplore;
  qs('#btnFight').onclick   = startBattle;
// BOSS 直進戰鬥（安全取當前小地圖）
qs('#btnBoss').onclick = function(){
  // 找到目前的小地圖資料
  var big = null, s = null, i, j;
  for (i=0;i<MAPS.length;i++){
    if (MAPS[i].id === curBig){ big = MAPS[i]; break; }
  }
  if (big && big.small){
    for (j=0;j<big.small.length;j++){
      if (big.small[j].id === curSmall){ s = big.small[j]; break; }
    }
  }
  var bossId = s && s.boss;
  if (!bossId){ log('這區沒有 BOSS'); return; }
  window.FORCE_MONSTER_ID = bossId; // 交給 startBattle 走既有流程
  startBattle();
};




  qs('#actAttack').onclick = playerAttack;
  qs('#actSkill').onclick  = openSkillMenu; // ★新增：打開技能選單
  qs('#actItem').onclick   = useItem;
  qs('#actRun').onclick    = tryRun;

  qs('#btnLeaveBattle').onclick = leaveBattle;

// ====== 技能系統函數 ======
function getAvailableSkills(){
  // 以 Game.getPlayer() 優先，否則用 P
  var pl = (window.Game && typeof Game.getPlayer === 'function') ? Game.getPlayer() : P;
  var out = new Set();

  function addId(raw){
    if(!raw) return;
    var s = String(raw).trim();
    if(!s) return;
    out.add(s);
  }
  function addFromArray(arr){
    for(var i=0;i<arr.length;i++){
      var v = arr[i];
      if(typeof v === 'string'){ addId(v); }
      else if(v && (v.id || v.skillId || v.key)){ addId(v.id || v.skillId || v.key); }
      else if(v && typeof v === 'object'){
        // 兼容 [{name:'xxx', id:'xxx'}] or [{sid:'xxx'}]
        addId(v.sid || v.name || v.title);
      }
    }
  }
  function addFromObject(obj){
    var ks = Object.keys(obj||{});
    for(var i=0;i<ks.length;i++){
      var k = ks[i]; var v = obj[k];
      var learned =
        v === true || v === 1 || v === '1' ||
        (v && (v.learned || v.unlocked || v.acquired || v.level > 0 || v.state === 'learned'));
      if(learned) addId(k);
      // 兼容 { k: { id:'xxx', learned:true } } 的怪格式
      if(v && (v.id || v.skillId) && (v.learned || v.unlocked || v.acquired || v.level > 0)){
        addId(v.id || v.skillId);
      }
    }
  }
  function collect(x){
    if(!x) return;
    if(Array.isArray(x)) return addFromArray(x);
    if(typeof x === 'string') return addId(x);
    if(typeof x === 'object') return addFromObject(x);
  }

  // 主要來源
  collect(pl && pl.skills);

  // 常見別名/其他存放點
  collect(pl && pl.skillsLearned);
  collect(pl && pl.skillsUnlocked);
  collect(pl && pl.skillSet);
  collect(pl && pl.skillMap);
  collect(pl && pl.skillIds);

  // 外觀/裝備可能掛的地方
  collect(pl && pl.appearance && pl.appearance.skills);
  collect(pl && pl.equip && pl.equip.skills);
  collect(pl && pl.equip && pl.equip.character && pl.equip.character.skills);

  // 最後輸出去重後的陣列
  return Array.from(out);
}


function renderSkillsPanel(){
// 🆕 野外地圖技能選單同步函數
// 當外觀系統更新技能時會呼叫此函數，重新整理技能選單
console.log('🎯 野外地圖技能選單已同步更新');

// 如果當前有技能選單開啟，重新渲染
var existingMenu = document.querySelector('[data-skill-menu="true"]');
if (existingMenu) {
  try {
    document.body.removeChild(existingMenu);
    // 延遲一點重新開啟，讓 DOM 有時間清理
    setTimeout(function() {
      if (battle && !battle.over && battle.p && battle.p.atb >= ATB_MAX) {
        openSkillMenu();
      }
    }, 100);
  } catch(_) {}
}
}


  // ====== 技能選單（動態建立覆蓋層）======

function openSkillMenu(){
  if(!battle || battle.over){ return; }
  // 🆕 與 updateCmdEnabled 的邏輯一致：必須滿 ATB_MAX 才能行動/開單
  if(!(battle.p && typeof ATB_MAX === 'number' && battle.p.atb >= ATB_MAX)){
    log('尚未輪到你行動'); 
    return;
  }

    var skills = getAvailableSkills();
    // 建立覆蓋層（沿用 useItem 的簡易樣式風格）
    var menu = document.createElement('div');
    menu.style.position='fixed';
    menu.style.left='0'; menu.style.top='0';
    menu.style.right='0'; menu.style.bottom='0';
    menu.style.zIndex='9999';
    menu.setAttribute('data-skill-menu', 'true');

    var mask = document.createElement('div');
    mask.style.position='absolute'; mask.style.left='0'; mask.style.top='0';
    mask.style.right='0'; mask.style.bottom='0'; mask.style.background='rgba(0,0,0,0.4)';
    menu.appendChild(mask);

    var sheet = document.createElement('div');
    sheet.style.position='absolute';
    sheet.style.left='50%'; sheet.style.top='50%';
    sheet.style.transform='translate(-50%,-50%)';
    sheet.style.width='min(680px, 92vw)';
    sheet.style.maxHeight='70vh';
    sheet.style.overflow='auto';
    sheet.style.background='#111';
    sheet.style.border='1px solid #333';
    sheet.style.borderRadius='10px';
    sheet.style.boxShadow='0 10px 30px rgba(0,0,0,0.5)';
    sheet.style.padding='8px 10px';
    menu.appendChild(sheet);

    var title = document.createElement('div');
    title.textContent='選擇技能';
    title.style.fontWeight='bold';
    title.style.fontSize='18px';
    title.style.padding='6px 2px 10px';
    sheet.appendChild(title);

    var box = document.createElement('div');
    sheet.appendChild(box);

    if(!skills.length){
      var row = document.createElement('div');
      row.textContent='尚未學會任何技能';
      row.style.textAlign='center'; row.style.padding='16px';
      box.appendChild(row);
    }else{
      for(var i=0;i<skills.length;i++){
        var sid = skills[i];
        var sk = null;
        if(window.SkillDB && typeof SkillDB.get === 'function'){
          var key = String(sid).trim();
          sk = SkillDB.get(key) || SkillDB.get(key.toLowerCase()) || SkillDB.get(key.toUpperCase());
        }
        if(!sk){
          console.warn('[skills] 找不到技能定義：', sid);
          continue;
        }

        // 🆕 檢查技能來源並添加標記
        var skillSource = '';
        if (P && P.skills && typeof P.skills === 'object' && P.skills[sid] && P.skills[sid].source === 'appearance') {
          skillSource = '（外觀技能）';
        }


        var row = document.createElement('div');
        row.style.display='grid';
        row.style.gridTemplateColumns='60px 1fr 90px';
        row.style.gridGap='10px';
        row.style.alignItems='center';
        row.style.padding='8px';
        row.style.border='1px solid #222';
        row.style.borderRadius='8px';
        row.style.margin='6px 0';
        row.style.background='#0b0b0b';

        // 圖示
        var ico = document.createElement('div');
        ico.style.width='60px'; ico.style.height='60px';
        ico.style.borderRadius='8px'; ico.style.background='#1a1a1a';
        ico.style.display='flex'; ico.style.alignItems='center'; ico.style.justifyContent='center';
        if(sk.icon){
          var im = document.createElement('img'); im.src=sk.icon; im.alt=sk.name||sid;
          im.style.maxWidth='60px'; im.style.maxHeight='60px';
          ico.appendChild(im);
        }else{
          ico.textContent='技';
        }
        row.appendChild(ico);

        // 文字
        var main = document.createElement('div');
        var nm = document.createElement('div');
        nm.textContent = (sk.name||sid);
        nm.style.fontWeight='bold'; nm.style.fontSize='16px';
        main.appendChild(nm);

        var sub = document.createElement('div');
        var elemText = (window.ELEMENT_LABEL && sk.elem) ? (ELEMENT_LABEL[sk.elem] || sk.elem) : '';
        var desc = (sk.desc || '') + (elemText ? ('　[屬性：' + elemText + ']') : '') + skillSource;
        sub.textContent = desc;
        sub.style.opacity='0.85';
        sub.style.fontSize='13px';
        sub.style.marginTop='4px';
        main.appendChild(sub);
        row.appendChild(main);

        // 操作
        var ops = document.createElement('div');
        var btn = document.createElement('button');
        btn.textContent='施 放（MP ' + (sk.mp||0) + '）';
        btn.className='btn primary';
        btn.style.width='100%';
        btn.setAttribute('data-skill', sid);
        ops.appendChild(btn);
        row.appendChild(ops);

        box.appendChild(row);
      }
    }

    // 點空白或右上角關閉
    mask.addEventListener('click', function(){ try{ document.body.removeChild(menu); }catch(_){ } });

    // 點「施放」
    sheet.addEventListener('click', function(e){
      var t = e.target || e.srcElement;
      var b = null;
      while(t && t !== sheet){
        if(t.getAttribute && t.getAttribute('data-skill')){ b=t; break; }
        t = t.parentNode;
      }
      if(!b) return;
      var sid = b.getAttribute('data-skill');
      var ok  = useSkill(sid);
      if(ok){ try{ document.body.removeChild(menu); }catch(_){ } }
    });

    document.body.appendChild(menu);
  }

  /* === 技能橫幅：施放時顯示透明警示＆畫面輕微滑動 === */
function showSkillBanner(skillName, elemKey){
  try{
    // 風格：元素中文名
    var elabel = (window.ELEMENT_LABEL && ELEMENT_LABEL[elemKey]) ? ELEMENT_LABEL[elemKey] : '無';
    // 外層
    var host = document.createElement('div');
    host.className = 'skill-banner';
    host.innerHTML =
      '<div class="wrap">'+
        '<div class="title">使 出 技 能</div>'+
        '<div class="name">'+ (skillName||'—') +'</div>'+
        '<div class="elem-pill '+(elemKey||'none')+'">'+ elabel +'</div>'+
      '</div>';
    document.body.appendChild(host);

    // 畫面滑動（相機微移）
    var app = document.querySelector('.app');
    if(app){ app.classList.add('pan'); setTimeout(function(){ app.classList.remove('pan'); }, 420); }

    // 自動移除
    setTimeout(function(){ try{ document.body.removeChild(host); }catch(_){ } }, 950);
  }catch(_){}
}


// ====== 施放技能（扣 MP、計算傷害、進入敵方回合）======
function useSkill(sid){
  if(!battle || battle.over) return false;
  if(!(battle.p && battle.p.atb >= ATB_MAX)){ log('尚未輪到你行動'); return false; }

  var sk  = (window.SkillDB && SkillDB.get) ? SkillDB.get(sid) : null;
  if(!sk){ log('未知技能：' + sid, 'warn'); return false; }

  // ── MP（真元）檢查
  var need = sk.mp || 0;
  var curMp = 0, mpMax = 0;
  if (P && P.mp && typeof P.mp === 'object') {
    curMp = +((P.mp.cur!=null)?P.mp.cur:0);
    mpMax = +((P.mp.max!=null)?P.mp.max:0);
  } else if (P && typeof P.mp === 'number') {
    curMp = P.mp|0;
    mpMax = Math.max(curMp, mpMax|0);
    P.mp = { cur: curMp, max: mpMax||curMp };
  }

  if(curMp < need){ log('真元不足（需要 ' + need + '）','warn'); return false; }

  // ── 扣除 MP
  var after = Math.max(0, curMp - need);
  if (P && P.mp && typeof P.mp === 'object') {
    P.mp.cur = after;
    if (mpMax > 0) P.mp.max = mpMax;
  }
  if (battle.p){
    battle.p.mp = after;
    if (typeof battle.p.mpMax === 'number' && mpMax > 0) battle.p.mpMax = mpMax;
  }

  // ★ 技能橫幅（透明警示＋畫面滑動）
  if (typeof showSkillBanner === 'function') {
    showSkillBanner(sk.name, sk.elem);
  }


  // ── 🔥 簡化的技能傷害計算（只用威力）
  if (!P._live) refreshLive();
  var baseDamage = P._live['物理攻擊'] || 10;

  // 技能威力直接作為倍率使用
  var skillMultiplier = (sk.power || 100) / 100; // 120 -> 1.2倍，150 -> 1.5倍

  // 計算技能傷害
  var skillDamage = baseDamage * skillMultiplier;

  // 暴擊判定 (10% 機率)
  var isCrit = Math.random() < 0.1;
  if (isCrit) {
    skillDamage *= 1.5;
  }

  // 隨機變動 (±20%)
  var dmg = Math.max(1, Math.floor(skillDamage * (0.8 + Math.random() * 0.4)));

  // 造成傷害
  battle.e.hp = Math.max(0, (battle.e.hp|0) - dmg);

  // 顯示戰鬥訊息
  var name = sk.name || sid;
  var criticalText = isCrit ? '（暴擊）' : '';
  log('你施放【' + name + '】對 ' + (battle.e.name||'敵人') + ' 造成 ' + dmg + ' 點傷害' + criticalText + '。');

  // ★雷落額外效果（保持原有邏輯）
  if(sid === 'thunder_drop' && P && P.element === 'spirit'){
    var heal = 20;
    var maxHp = (battle.p && battle.p.hpMax) ? battle.p.hpMax : ((P.hp && P.hp.max) ? P.hp.max : 0);
    var curHp = (battle.p && typeof battle.p.hp === 'number') ? battle.p.hp : ((P.hp && P.hp.cur) ? P.hp.cur : 0);
    curHp = Math.min(maxHp, curHp + heal);
    if(battle.p) battle.p.hp = curHp;
    if(P && P.hp){ P.hp.cur = curHp; P.hp.max = maxHp; }
    log('雷落追加效果：你回復 ' + heal + ' 點氣血。','ok');
  }

  // 重置我方 ATB，輪到敵方
  battle.p.atb = 0;
  updateBattleBars();
  if(battle.e.hp <= 0){ endCheck(); return true; }

  setTimeout(function(){ enemyAttack(); }, 400);
  return true;
}


/* ===== 啟動（以 API 為主，必要時用本地較新快取）===== */
window.addEventListener('DOMContentLoaded', async function(){
  // 1) 登入檢查
  var user = (window.Auth && Auth.currentUser) ? Auth.currentUser() : null;
  if(!user){ location.href = 'index.html'; return; }

  // 2) 讀雲端角色
  var char = null;
  try{
    char = (window.Auth && Auth.loadCharacter) ? (await Auth.loadCharacter()) : null;
  }catch(e){
    char = null;
  }

  // 3) 若本地快取較新 → 優先用本地（避免剛在主城存檔尚未同步）
  var cached = (window.Auth && Auth.getCharacter) ? Auth.getCharacter() : null;
  if (cached){
    var useCached = false;
    if (!char){ useCached = true; }
    else{
      var t1 = (cached && cached._updatedAt) ? cached._updatedAt : 0;
      var t2 = (char   && char._updatedAt)   ? char._updatedAt   : 0;
      if (t1 > t2){ useCached = true; }
    }
    if (useCached){ char = cached; }
  }

  if(!char){ location.href = 'index.html#create'; return; }

  // 4) 以 API 為主：把資料寫入全域 P，地圖上所有顯示都讀 P
  P = char;

  // 5) 掛裝備模組（此時 P 已可用）
  if (window.Equip && Equip.mount) {
    Equip.mount({
      getPlayer: function(){ return P; },
      save:      function(){ try{ if (window.Auth && Auth.saveCharacter && P){ var cleanData = JSON.parse(JSON.stringify(P)); delete cleanData._live; Auth.saveCharacter(cleanData); } }catch(_){ } },
      recalc:    function(){ try{ renderHeader(); renderBars(); }catch(_){} },
      log:       function(t){ try{ console.log(t); }catch(_){} }
    });
  }

  // 6) 啟動後第一次渲染
  console.log('🚀 頁面載入完成 - 角色狀態:', {
    level: P.level,
    exp: P.exp,
    hp: P.hp,
    sta: P.sta,
    currencies: P.currencies
  });
  
  renderHeader();
  refreshLive();
  renderBars();
  buildMapUI();
  setLocBadge();
  updateActionPanel();

});



</script>
</body>
</html>