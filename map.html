<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>修仙RPG｜野外地圖＆戰鬥</title>
  <style>
    :root{
      --bg:#0b1024; --bg2:#0e1536; --panel:#131a3f; --panel-2:#0f1534; --muted:#9aa3b2; --text:#eaf2ff;
      --accent:#8b5cf6; --accent2:#22d3ee; --hp:#ef4444; --mp:#3b82f6; --bar:#334155; --ok:#22c55e; --warn:#f59e0b;
      --gold:#b98c4b; --gold-2:#7a5b31; --radius:16px; --gap:12px; --shadow:0 10px 28px rgba(0,0,0,.35);
      --elem-none:#64748b; --elem-gold:#f59e0b; --elem-wood:#22c55e; --elem-water:#38bdf8;
      --elem-fire:#f97316; --elem-earth:#a16207; --elem-spirit:#a78bfa; --elem-dark:#0f172a;
    }
    *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
    html,body{height:100%; margin:0; font-family:"Microsoft JhengHei",system-ui,Segoe UI,Roboto,sans-serif; color:var(--text); background:var(--bg);}

    .stage{
      position:fixed; inset:0;
      display:grid;
      align-items:start;            /* 讓畫面貼齊頂部*/
      justify-items:center;
      overflow:auto;
      padding-top:env(safe-area-inset-top); /* 保留瀏海安全區 */
    }

    .app{
      aspect-ratio: 93/150;
      width: min(100svw, calc(100svh * 93/150));
      max-height: 100svh;
      background: linear-gradient(180deg, var(--bg2), var(--panel));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      display:flex; flex-direction:column; overflow:hidden;
    }
    /* 手機直立優化：讓 App 直接填滿視窗，去掉上下黑邊 */
    @media (max-width: 480px){
      .app{
        width: 100svw;
        height: 100svh;       /* 直接吃滿可視高度 */
        max-height: none;
        aspect-ratio: auto;   /* 取消固定比例 */
        border-radius: 0;     /* 視覺貼齊螢幕邊緣（可移除） */
      }
    }

    /* Header */
    header{
      padding:10px 12px; background:rgba(255,255,255,.06);
      border-bottom:1px solid rgba(255,255,255,.08);
      display:grid; grid-template-columns:1fr auto; grid-template-areas: "left right" "medals right";
      gap:8px 10px; align-items:center;
    }
    .h-left{grid-area:left; display:grid; grid-template-columns:auto 1fr; gap:10px; align-items:center; min-width:0;}
    .avatar{width:44px; height:44px; border-radius:50%; object-fit:cover; background:#222; border:2px solid rgba(255,255,255,.15);}
    .pinfo{display:flex; flex-direction:column; min-width:0;}
    .prow{display:flex; align-items:center; gap:6px; flex-wrap:nowrap; min-width:0;}
    .pname{font-weight:700; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .plv{font-size:12px; opacity:.9;}
    .pill{
      display:inline-flex; align-items:center; gap:6px; padding:2px 8px; border-radius:999px; font-size:12px;
      background:rgba(255,255,255,0.08);
    }
    .pill.elem{ color:#fff; font-weight:600; }
    .pill.elem.none{  background:var(--elem-none);  }
    .pill.elem.gold{  background:var(--elem-gold);  }
    .pill.elem.wood{  background:var(--elem-wood);  }
    .pill.elem.water{ background:var(--elem-water); }
    .pill.elem.fire{  background:var(--elem-fire);  }
    .pill.elem.earth{ background:var(--elem-earth); }
    .pill.elem.spirit{background:var(--elem-spirit);}
    .pill.elem.dark{  background:var(--elem-dark);  }

    .medals{grid-area:medals; display:flex; gap:6px; min-width:0;}
    .medal-slot{width:30px; aspect-ratio:1/1; border-radius:50%; border:2px solid rgba(255,255,255,.25);
      display:flex; align-items:center; justify-content:center; font-size:12px; color:#cbd5e1; background:rgba(255,255,255,.06);
      overflow:hidden; flex:0 0 auto;}
    .h-right{grid-area:right; display:flex; flex-direction:column; align-items:flex-end; gap:8px; min-width:0;}
    .coins{display:flex; gap:8px; white-space:nowrap; min-width:0; flex-wrap:nowrap;}
    .coin{display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); font-size:12px;}
    .icon-box{ width:18px; height:18px; border-radius:4px; overflow:hidden; display:grid; place-items:center; }
    .icon-box img{ width:100%; height:100%; object-fit:cover; display:block; }
    .val{max-width:140px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}
    .back-btn{padding:5px 10px; min-width:76px; font-size:12px; border-radius:999px; border:1px solid rgba(255,255,255,.2); background:#111827; color:#fff; font-weight:800; cursor:pointer; letter-spacing:.5px;}
    .logout-btn{padding:5px 10px; min-width:76px; font-size:12px; border-radius:999px; border:1px solid rgba(255,255,255,.2); background:#ef4444; color:#fff; font-weight:800; cursor:pointer; letter-spacing:.5px;}

    .divider{height:1px; background:rgba(255,255,255,.08); margin:6px 0;}
    .main{flex:1; display:flex; flex-direction:column; gap:10px; padding:8px 12px 10px; overflow:auto;}

    /* Bars（縮小字級＋更細能量條） */
    .bars{display:grid; gap:6px;}
    .stat-row{display:grid; grid-template-columns:48px 1fr 56px; align-items:center; gap:6px;}
    .label{font-size:12px; color:#e2e8f0; text-align:right;}
    .num{font-size:11px; color:#e2e8f0; text-align:right;}
    .prog{height:8px; background:#1f273a; border-radius:999px; position:relative; overflow:hidden; box-shadow: inset 0 1px 0 rgba(255,255,255,.06), inset 0 -1px 0 rgba(0,0,0,.25);}
    .fill{height:100%; width:0%;}
      .fill.sta{background:linear-gradient(90deg,#eab308,#f59e0b);}
      .fill.exp{background:linear-gradient(90deg,#16a34a,#4ade80);}
      .fill.hp{background:linear-gradient(90deg,#ef4444,#b91c1c);}
      .fill.mp{background:linear-gradient(90deg,#3b82f6,#1d4ed8);}

    /* Map selection */
    .map-wrap{display:grid; gap:10px;}
    .title{text-align:center; color:#c7d2fe; font-weight:900; letter-spacing:4px; padding-top:2px; font-size:14px;}

    /* 兩列選單：左＝大地圖（清單）／右＝副地圖（清單） */
    .map-select{display:grid; grid-template-columns: 1fr 1fr; gap:10px;}
    .col{
      background:rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.08);
      border-radius:14px; padding:8px; display:grid; grid-template-rows:auto 1fr;
      gap:8px; min-height:160px;
    }
    .col .clabel{font-size:12px; color:#a5b4fc; letter-spacing:2px;}
    .col .opts{
      display:flex; flex-direction:column; gap:6px; overflow:auto; padding-right:2px;
      -webkit-overflow-scrolling:touch;
    }
    /* 清單條目（字小、整行可點） */
    .tag{
      display:flex; align-items:center; justify-content:space-between; width:100%;
      padding:6px 10px; font-size:12px; border-radius:10px;
      border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.06);
      cursor:pointer; user-select:none;
    }
    .tag .name{flex:1; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}
    .tag .lv{margin-left:8px; font-size:11px; color:#93c5fd; opacity:.95; white-space:nowrap;}
    .tag{padding:4px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.10); cursor:pointer; user-select:none; font-size:11px; line-height:1.1;}
    .tag.active{background:linear-gradient(135deg,var(--accent),var(--accent2));}

    /* 進入/動作區 */
    .panel{background:rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:8px; display:grid; gap:8px;}
    .btn{padding:8px 12px; border-radius:10px; border:1px solid rgba(255,255,255,.18); background:linear-gradient(135deg,var(--accent),var(--accent2)); color:#fff; font-weight:800; text-align:center; cursor:pointer; user-select:none;}
    .btn.ghost{background:transparent; color:#fff; border:1px solid rgba(255,255,255,.2);}
    .btn[disabled]{opacity:.5; filter:grayscale(1); cursor:not-allowed;}

    .row{display:flex; gap:8px; flex-wrap:wrap;}
    .hint{font-size:12px; color:#93c5fd; text-align:center;}

   /* === 地區情報（固定欄位・雙欄） === */
    .panel.info{ padding:6px 8px; }
    .info-title{
      font-size:11px; color:#a5b4fc; letter-spacing:1.5px;
      margin-bottom:4px; opacity:.95;
    }
    /* 固定雙欄：左欄較寬（怪物），右欄稍窄（事件） */
    .info-grid{
      display:grid; grid-template-columns: minmax(0,1.35fr) minmax(0,.85fr);
      gap:6px 10px; align-items:start;
    }
    .info-col{ display:grid; gap:4px; min-width:0; }
    .info-label{ font-size:11px; color:#e2e8f0; opacity:.8; }

    /* 怪物膠囊（更緊湊） */
    .chip-list{ display:flex; flex-wrap:wrap; gap:6px; }
    .chip{
      display:inline-flex; align-items:center; gap:6px;
      padding:3px 6px; border-radius:8px;
      border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.08);
      font-size:11px; line-height:1.1; white-space:nowrap;
      max-width:100%;
    }
    .chip .mname{
      max-width:120px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
    }
    .chip .mlv{ font-size:10px; opacity:.75; }

    /* 地區情報中的元素膠囊縮小一號 */
    .info .pill.elem{
      padding:0 6px; border-radius:8px;
      font-size:10px; line-height:1.1;
    }

    /* 事件列表（真正齊頭：把分隔點放在前一個項目的尾端） */
    .event-list{
      display:flex; flex-wrap:wrap; gap:6px 10px;
      margin:0; padding:0; list-style:none; font-size:11px; color:#cbd5e1;
    }
    .event-list li{
      display:flex; align-items:center;
    }
    .event-list li::before{ content:''; } /* 清空上一版的前置點（避免快取造成殘留） */
    .event-list li:not(:last-child)::after{
      content:'・'; margin-left:6px; opacity:.55;
    }


    /* Battle UI */
    .battle{display:none; grid-template-rows:auto 1fr auto; gap:10px; min-height:340px;}
    .battle.show{display:grid;}
    .arena{display:grid; grid-template-columns:1fr 1fr; gap:8px; align-items:end; padding:8px; border-radius:12px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12);}
    .box{background:rgba(0,0,0,.3); border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:8px; display:grid; gap:8px;}
    /* 立繪容器（保留一點邊距） */
    .art{
      width:100%; height:112px;
      border-radius:10px;
      background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(0,0,0,.15));
      display:grid; place-items:center; overflow:hidden;
      border:1px solid rgba(255,255,255,.08);
      position:relative;
    }

    /* 100×100 頭像框：玩家圓形、敵人方形 */
    .frame{
      width:100px; height:100px;
      display:grid; place-items:center;
      overflow:hidden;
      background:rgba(0,0,0,.15);
      border:1px solid rgba(255,255,255,.12);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
    }
    .p-frame{ border-radius:50%; }        /* 玩家圓形 */
    .e-frame{ border-radius:12px; }       /* 敵人方形，帶一點圓角 */

    /* 內部圖片：以 100×100 素材為主，保持完整顯示 */
    .portrait{
      width:100%; height:100%;
      object-fit:contain; display:block;
      image-rendering:auto;
      filter: drop-shadow(0 4px 6px rgba(0,0,0,.35));
    }
    .portrait.mirror{ transform: scaleX(-1); }

    .who{display:flex; align-items:center; justify-content:space-between; gap:8px;}
    .name{font-weight:900;}
    .hpbar{height:10px; background:#1f273a; border-radius:999px; overflow:hidden;}
    .hpfill{height:100%; width:0%; background:linear-gradient(90deg,#ef4444,#b91c1c);}
    .atb{height:10px; background:#0b122b; border-radius:999px; overflow:hidden;}
    .atbfill{height:100%; width:0%; background:linear-gradient(90deg,#22d3ee,#8b5cf6);}
    .srow{display:flex; gap:10px; font-size:12px; color:#cbd5e1;}
    .cmd{display:grid; grid-template-columns:repeat(4,1fr); gap:8px;}
    .cbtn{padding:10px 6px; text-align:center; border-radius:10px; border:1px solid rgba(255,255,255,.2);
      background:linear-gradient(#a6783e,#7f5626); box-shadow: inset 0 2px 0 rgba(255,255,255,.15), 0 2px 0 rgba(0,0,0,.2);
      font-weight:800; letter-spacing:2px; color:#fff; cursor:pointer; user-select:none;}
    .cbtn[disabled]{opacity:.5; filter:grayscale(1); cursor:not-allowed;}
    /* ★ 改善戰鬥／地圖日誌：加大、加行距、背景透黑，並加入分類色 */
    .log{
      height:110px;
      overflow:auto;
      padding:10px 12px;
      font-size:13px;
      line-height:1.4;
      background:rgba(6,10,26,0.8);
      border:1px solid rgba(255,255,255,.3);
      border-radius:10px;
    }
    /* 每條訊息底下留一點間距 */
    .log > div{ margin-bottom:4px; }
    /* 日誌分類顏色：呼應全域變數 ok/warn/hp 等 */
    .log .ok  { color: var(--ok);   }
    .log .warn{ color: var(--warn); }
    .log .hit { color: var(--hp);   }
    .log .crit{ color:#ffd166;     }
    .log .heal{ color:#34d399;     }


    .footrow{display:flex; gap:8px; justify-content:space-between; align-items:center;}
    .locBadge{font-size:12px; color:#e2e8f0;}

    /* ===== 受擊/浮字特效 ===== */
    .art{ position:relative; }            /* 讓 fx 可以絕對定位在立繪上 */
    .fx{ position:absolute; inset:0; pointer-events:none; overflow:visible; }
    .dmg-float{
      position:absolute; left:50%; top:45%;
      transform: translate(-50%,-50%);
      font-weight:900; font-size:22px; letter-spacing:1px;
      text-shadow:0 2px 0 rgba(0,0,0,.35), 0 0 12px rgba(255,255,255,.2);
      animation: rise 900ms ease-out forwards;
      user-select:none; white-space:nowrap;
    }
    .dmg-float.crit{ font-size:26px; filter: drop-shadow(0 0 8px rgba(255,215,0,.55)); }
    .dmg{ color:#ff6b6b; }
    .heal{ color:#34d399; }
    .crit{ color:#ffd166; }

    .flash{
      position:absolute; inset:0;
      background: radial-gradient( circle at 50% 45%, rgba(255,80,80,.55), rgba(255,0,0,.15) 60%, transparent 70% );
      mix-blend-mode: screen;
      border-radius:10px;
      animation: flash 220ms ease-out forwards;
    }

    .portrait.shake{ animation: shake .28s cubic-bezier(.36,.07,.19,.97) 2; transform-origin:center; }

    @keyframes flash{
      0%{ opacity:0; }
      10%{ opacity:.95; }
      100%{ opacity:0; }
    }
    @keyframes rise{
      0%{ transform:translate(-50%,-20%) scale(.9); opacity:0; }
      15%{ transform:translate(-50%,-40%) scale(1.05); opacity:1; }
      100%{ transform:translate(-50%,-110%) scale(1.0); opacity:0; }
    }
    @keyframes shake{
      10%, 90% { transform: translateX(-1px); }
      20%, 80% { transform: translateX(2px); }
      30%, 50%, 70% { transform: translateX(-4px); }
      40%, 60% { transform: translateX(4px); }
    } 
  </style>
</head>
<body>
<div class="stage">
  <div class="app">
    <header>
      <div class="h-left">
        <img id="uiAvatar" class="avatar" alt="avatar" />
        <div class="pinfo">
          <div class="prow">
            <div class="pname" id="uiName"></div>
            <div class="plv">LV.<span id="uiLv"></span></div>
            <span id="uiElem" class="pill elem none"></span>
          </div>
        </div>
      </div>
      <div class="medals">
        <div class="medal-slot" id="medal1"></div>
        <div class="medal-slot" id="medal2"></div>
        <div class="medal-slot" id="medal3"></div>
        <div class="medal-slot" id="medal4"></div>
        <div class="medal-slot" id="medal5"></div>
      </div>
      <div class="h-right">
        <div class="coins">
          <span class="coin">
            <span class="icon-box"><img alt="靈石" src="https://upload.wikimedia.org/wikipedia/commons/9/9d/Crystal_128_up.png"></span>
            <span class="val" id="uiStone">0</span>
          </span>
          <span class="coin">
            <span class="icon-box"><img alt="鑽石" src="https://upload.wikimedia.org/wikipedia/commons/0/0a/Diamond_Icon.svg"></span>
            <span class="val" id="uiDiamond">0</span>
          </span>
        </div>
        <div class="row">
          <button id="btnBackHome" class="back-btn" title="返回主城">返回主城</button>
          <button id="btnLogout" class="logout-btn" title="登出" aria-label="登出">登出</button>
        </div>
      </div>
    </header>

    <div class="divider"></div>

    <div class="main">
      <!-- 顯示體力/經驗/氣血 -->
    <div class="bars">
      <div class="stat-row">
        <div class="label">體力：</div>
        <div class="prog"><div class="fill sta" id="barSta"></div></div>
        <div class="num" id="txtSta">100/100</div>
      </div>
      <div class="stat-row">
        <div class="label">經驗：</div>
        <div class="prog"><div class="fill exp" id="barExp"></div></div>
        <div class="num" id="txtExp">0/100</div>
      </div>
      <div class="stat-row">
        <div class="label">氣血：</div>
        <div class="prog"><div class="fill hp" id="barHp"></div></div>
        <div class="num" id="txtHp">--/--</div>
      </div>
      <div class="stat-row">
        <div class="label">真元：</div>
        <div class="prog"><div class="fill mp" id="barMp"></div></div>
        <div class="num" id="txtMp">--/--</div>
      </div>
    </div>

<!-- 地圖選擇 -->
      <div id="mapSection" class="map-wrap">
        <div class="title">野 外 地 圖</div>

        <!-- 兩列選單：左大地圖、右副地圖（依左側選擇動態變化） -->
        <div class="map-select">
          <div class="col">
            <div class="clabel">大地圖</div>
            <div class="opts" id="bigMapCol"></div>
          </div>
          <div class="col">
            <div class="clabel">副地圖</div>
            <div class="opts" id="smallMapCol"></div>
          </div>
        </div>

        <!-- 先按「進入」才會顯示探險/戰鬥 -->
      <div class="panel">
        <div class="locBadge" id="locBadge">尚未選擇地點</div>
        <div class="row">
          <button id="btnEnter"   class="btn" disabled>進 入</button>
          <button id="btnExplore" class="btn" style="display:none;">探險（體力-2）</button>
          <button id="btnFight"   class="btn" style="display:none;">戰 鬥</button>
          <!-- ★ 新增：挑戰 BOSS（紅色） -->
          <button id="btnBoss"    class="btn" style="display:none; background:#b91c1c; border:1px solid #dc2626;">挑戰 BOSS</button>
        </div>
        <div class="hint">請先選擇「大地圖 → 副地圖」並按下「進入」。進入後才會顯示「探險 / 戰鬥」。</div>
        <!-- ★ 新增：萊姆洞窟進度提示 -->
        <div id="slimeQuestHint" class="hint" style="display:none;"></div>
      </div>

        <!-- ★ 地區情報（固定欄位｜雙欄：左=怪物，右=事件） -->
        <div class="panel info" id="areaInfo">
          <div class="info-title">地 區 情 報</div>
          <div class="info-grid">
            <div class="info-col info-left">
              <div class="info-label">可能出現的怪物</div>
              <div id="infoMonsters" class="chip-list"><span class="chip">—</span></div>
            </div>
            <div class="info-col info-right">
              <div class="info-label">探險可能事件</div>
              <ul id="infoEvents" class="event-list">
                <li>撿到靈石（約 50%）</li>
                <li>發現素材（約 30%）</li>
                <li>獲得丹藥（約 20%）</li>
              </ul>
            </div>
          </div>
        </div>

        <!-- ★ 事件／戰鬥日誌（與戰鬥共用同一個 #log） -->
        <div class="panel">
          <div class="log" id="logMap"></div>
        </div>
      </div>

      <!-- 戰鬥場景 -->
      <div id="battleSection" class="battle">
        <div class="arena">
        <div class="box">
          <div class="who">
          <div class="name">你</div>
          <div class="srow">
            <span>LV.<span id="pLv"></span></span>
            <span id="pElem" class="pill elem">—</span>
          </div>
        </div>
          <div class="art">
            <div class="frame p-frame">
              <img id="pImg" class="portrait" alt="player portrait">
            </div>
            <div class="fx" id="pFx"></div>
          </div>
          <div class="hpbar"><div id="pHp" class="hpfill"></div></div>
          <div class="atb"><div id="pATB" class="atbfill"></div></div>
        </div>
        <div class="box">
          <div class="who">
          <div class="name" id="eName">敵人</div>
          <div class="srow">
            <span>LV.<span id="eLv"></span></span>
            <span id="eElem" class="pill elem">—</span>
          </div>
        </div>
          <div class="art">
            <div class="frame e-frame">
              <img id="eImg" class="portrait mirror" alt="enemy portrait">
            </div>
            <div class="fx" id="eFx"></div>
          </div>
          <div class="hpbar"><div id="eHp" class="hpfill"></div></div>
          <div class="atb"><div id="eATB" class="atbfill"></div></div>
        </div>
        </div>
        <div class="cmd">
          <button id="actAttack" class="cbtn" disabled>攻 擊</button>
          <button id="actSkill"  class="cbtn" disabled title="預留">技 能</button>
          <button id="actItem"   class="cbtn" disabled>道 具</button>
          <button id="actRun"    class="cbtn" disabled>逃 跑</button>
        </div>
        <div class="log" id="logBattle"></div>
        <div class="footrow">
          <div id="btState" class="locBadge"></div>
          <div class="row">
            <button id="btnLeaveBattle" class="btn ghost" style="display:none;">返回小地圖</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Firebase（compat 版，免 ES Module） -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
<script>
  (function(){
    var firebaseConfig = {
      apiKey: "AIzaSyBvKmn0jCTS_jIgEYOuQjc8vyYU40Q5F3I",
      authDomain: "stellarblue-system.firebaseapp.com",
      databaseURL: "https://stellarblue-system-default-rtdb.firebaseio.com",
      projectId: "stellarblue-system",
      storageBucket: "stellarblue-system.firebasestorage.app",
      messagingSenderId: "803212433649",
      appId: "1:803212433649:web:887080d10a51d533b23150",
      measurementId: "G-YY94484DV9"
    };
    if(!firebase.apps || !firebase.apps.length){
      firebase.initializeApp(firebaseConfig);
    }
    // 提供給 auth.js 使用
    window.DB = firebase.database();
  })();
</script>

<!-- 資料庫/帳號 -->
<script src="items.js"></script>
<script src="monsters.js"></script>
<script src="auth.js"></script>


<script>
/* ===== 工具 ===== */
const qs = (s, p=document)=>p.querySelector(s);
const qsa = function(s, p){
  p = p || document;
  return Array.prototype.slice.call(p.querySelectorAll(s));
};
const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
const pct=(cur,max)=> (max>0? clamp(Math.round(cur/max*100),0,100) : 0);
const fmt=(n)=> new Intl.NumberFormat('zh-Hant').format(n);

/* ===== 元素＆相剋表 ===== */
const ELEMENT_LABEL = {
  none:'無', gold:'金', wood:'木', water:'水', fire:'火', earth:'土', spirit:'靈', dark:'暗'
};

// 1) 相剋倍率（v1：五行相剋＋暗/靈互克；強 1.25×、弱 0.75×、其餘 1.00）

window.ELEM_MUL = {
  none:  { none:1, gold:1,   wood:1,    water:1,    fire:1,    earth:1,   spirit:1,   dark:1 },
  gold:  { none:1, gold:1,   wood:1.25, water:1,    fire:0.75, earth:1,   spirit:1,   dark:1 },
  wood:  { none:1, gold:0.75,wood:1,    water:1,    fire:0.75, earth:1.25,spirit:1,   dark:1 },
  water: { none:1, gold:1,   wood:1,    water:1,    fire:1.25, earth:0.75,spirit:1,   dark:1 },
  fire:  { none:1, gold:1.25,wood:1.25, water:0.75, fire:1,    earth:1,   spirit:1,   dark:1 },
  earth: { none:1, gold:1,   wood:0.75, water:1.25, fire:1,    earth:1,   spirit:1,   dark:1 },
  spirit:{ none:1, gold:1,   wood:1,    water:1,    fire:1,    earth:1,   spirit:1,   dark:1.25 },
  dark:  { none:1, gold:1,   wood:1,    water:1,    fire:1,    earth:1,   spirit:1.25,dark:1 },
};


// 2) 同屬性加成（Same-Type Attack Bonus）：攻擊者元素==攻擊元素 → +10%
window.STAB = 1.00;

// 3) 取倍率工具
function elemMult(dmgElem='none', defElem='none'){
  const row = (window.ELEM_MUL||{})[dmgElem]||{};
  return row[defElem] ?? 1;
}
// 將元素對應關係轉成易讀的片語（固定顯示，×1.00 也會寫出來）
function elemRelationText(atkElem, defElem, elemMul, stabMul){
  const name = (k)=> (ELEMENT_LABEL?.[k] || k || '無');
  const parts = [`相性：${name(atkElem)}→${name(defElem)} ×${(elemMul||1).toFixed(2)}`];
  if ((stabMul||1) > 1) parts.push(`同屬 +${Math.round((stabMul-1)*100)}%`);
  return '（' + parts.join('；') + '）';
}

// 玩家預設立繪（若沒有 avatar 才用這張）
const PLAYER_IMG_URL = 'https://picsum.photos/seed/xian-hero/400/600';



/* ===== 地圖資料（大地圖 -> 小地圖） ===== */
const MAPS = [
  { id:'forest', name:'青木山脈', lv:'1-4', small:[
    { id:'slime_cave',  name:'萊姆洞窟', lv:'1-3',
      monsters:['slime_young','slime','slime_king'], boss:'slime_boss' },
    { id:'woodland',    name:'靈木林',   lv:'2-3',
      monsters:['thorn_fox','wood_wisp','brass_beetle'] },
    { id:'moss_vale',   name:'苔石谷',   lv:'2-4',
      monsters:['slime','stone_golem'],  boss:'stone_golem_boss' },
  ]},
  { id:'tundra', name:'雪原台地', lv:'3-5', small:[
    { id:'snowfield',   name:'雪原狩場', lv:'3-4',
      monsters:['snow_wolf','ice_thorn'], boss:'ice_bear_boss' },
    { id:'ice_cave',    name:'寒晶洞穴', lv:'4-5',
      monsters:['ice_bear','ice_thorn'] },
  ]},
  { id:'ruins', name:'幽怨遺跡', lv:'5-7', small:[
    { id:'spirit_hall', name:'靈侍大殿', lv:'4-6',
      monsters:['spirit_acolyte','wraith'], boss:'spirit_acolyte_boss' },
    { id:'shadow_pit',  name:'影翼深坑', lv:'4-6',
      monsters:['shadow_bat','wraith'],     boss:'shadow_bat_boss' },
  ]},
  { id:'canyon', name:'磐石峽谷', lv:'3-6', small:[
    { id:'beetle_ridge', name:'雷角嶺',  lv:'5-6',
      monsters:['brass_beetle','thunder_beetle'], boss:'thunder_beetle_boss' },
    { id:'bog',          name:'泥潭窪地',lv:'3-5',
      monsters:['bog_tortoise','stone_golem'],    boss:'ancient_tortoise_boss' },
  ]},
];



/* ===== 玩家/導入角色 ===== */
let P = null;           // 玩家角色
let curBig = null;      // 現在選的大地圖 id
let curSmall = null;    // 現在選的小地圖 id
let entered = false;    // 是否已按「進入」，未進入前不顯示探險/戰鬥

// 取得玩家（從 Auth / localStorage）
function loadPlayer(){
  if(!window.Auth || !Auth.getCharacter){ alert('找不到帳號系統'); return null; }
  const c = Auth.getCharacter();
  if(!c){ location.href = 'index.html#create'; return null; }

  // 確保背包存在 & 結構齊全
  if(!c.bag){
    c.bag = (window.ItemDB && ItemDB.getDefaultBag) ? ItemDB.getDefaultBag() 
      : { consumables:[], weapons:[], ornaments:[], materials:[], hidden:[] };
  }else{
    c.bag.consumables = Array.isArray(c.bag.consumables) ? c.bag.consumables : [];
    c.bag.weapons     = Array.isArray(c.bag.weapons)     ? c.bag.weapons     : [];
    c.bag.ornaments   = Array.isArray(c.bag.ornaments)   ? c.bag.ornaments   : [];
    c.bag.materials   = Array.isArray(c.bag.materials)   ? c.bag.materials   : [];
    c.bag.hidden      = Array.isArray(c.bag.hidden)      ? c.bag.hidden      : [];
  }

  // HP 欄位若不存在，建立（沿用你的衍生規則）
  if(!c.hp){ 
    const d=derivedFrom(c); 
    c.hp = { cur:d['氣血上限'], max:d['氣血上限'] }; 
  }
  // ★ 副地圖進度（萊姆洞窟）
  c.mapProg = c.mapProg || {};
  c.mapProg.slime_cave = c.mapProg.slime_cave || { kills:0, bossReady:false };

  return c;
}

function savePlayer(){ if(window.Auth && Auth.saveCharacter) Auth.saveCharacter(P); }

/* ===== 衍生能力（與主城公式一致） ===== */
function derivedFrom(player){
  const A = player.attributes || {str:10, vit:10, dex:10, int:10, wis:10, luk:10};
  const level = player.level ?? 1;
  return {
    '物理攻擊': A.str*2 + level,
    '法術攻擊': A.int*2 + Math.floor(A.wis*0.5),
    '氣血上限': 80 + A.vit*12 + level*6,
    '真元上限': 40 + A.wis*10 + Math.floor(A.int*6/5),
    '物理防禦': Math.floor(A.vit*1.2) + Math.floor(A.dex*0.6),
    '法術防禦': Math.floor(A.wis*1.3) + Math.floor(A.int*0.5),
    '命中率': 60 + A.dex*2,
    '閃避': 5 + Math.floor(A.dex*1.2),
    '暴擊率': Math.min(50, 3 + Math.floor(A.luk*0.8)),
    '暴擊傷害': 50 + Math.floor(A.luk*1.5),
    '行動條速度': 100 + Math.floor(A.dex*2.2), // 以此轉換為 ATB 速度
    '回氣/回合': 2 + Math.floor(A.wis*0.4),
    '回血/回合': 1 + Math.floor(A.vit*0.5),
    '破甲': Math.floor(A.str*0.6),
    '法穿': Math.floor(A.int*0.6),
  };
}
// === 只算一次的「最終能力快照」：基礎衍生 + 裝備加成 ===
function finalDerived(player){
  var base  = (typeof derivedFrom==='function') ? (derivedFrom(player)||{}) : {};
  var bonus = (window.Equip && typeof Equip.getBonuses==='function') ? (Equip.getBonuses()||{}) : {};
  var out = {};
  // 相當於 { ...base }
  for (var k in base) {
    if (Object.prototype.hasOwnProperty.call(base, k)) out[k] = base[k];
  }
  // 疊加裝備加成
  for (var k2 in bonus) {
    if (Object.prototype.hasOwnProperty.call(bonus, k2)) {
      out[k2] = (out[k2]||0) + (bonus[k2]||0);
    }
  }
  return out;
}



// 重新整理快照（進地圖、開始戰鬥、升級後都可呼叫）
function refreshLive(){
  if(!P) return;
  P._live = finalDerived(P);
}

/* ===== UI Render ===== */
function renderHeader(){
  const fallbackAvatar = (typeof Auth!=='undefined' && Auth.defaultAvatar)
    ? (Auth.defaultAvatar() || 'https://picsum.photos/seed/xian/96')
    : 'https://picsum.photos/seed/xian/96';
  qs('#uiAvatar').src = P.avatar || fallbackAvatar;
  qs('#uiName').textContent = P.name || '無名散修';
  qs('#uiLv').textContent   = P.level ?? 1;
  const elem = (P.element || 'none').toLowerCase();
  const elemEl = qs('#uiElem'); elemEl.className = `pill elem ${elem}`; elemEl.textContent = ELEMENT_LABEL[elem] || '無元素';

  qs('#uiStone').textContent   = fmt(P.currencies?.stone || 0);
  qs('#uiDiamond').textContent = fmt(P.currencies?.diamond || 0);
}

 // 玩家進入後連動的能量條

function renderBars(){
  if (!P) return;                      // ← 用全域 P（在 start() 由 loadPlayer() 載入）
  if (!P._live) refreshLive();
  const d = P._live;


  // 體力 / 經驗：保留原值，若不存在才給預設，並做夾限
  if (!P.sta) P.sta = { cur:100, max:100 };
  P.sta.max = P.sta.max ?? 100;
  P.sta.cur = Math.max(0, Math.min(P.sta.cur ?? P.sta.max, P.sta.max));

  if (!P.exp) P.exp = { cur:0, max:100 };
  P.exp.max = P.exp.max ?? 100;
  P.exp.cur = Math.max(0, Math.min(P.exp.cur ?? 0, P.exp.max));

  // 氣血（由屬性推上限，再夾限目前值）
  const hpMax = d['氣血上限'];
  if (!P.hp) P.hp = { cur:hpMax, max:hpMax };
  P.hp.max = hpMax;
  P.hp.cur = Math.max(0, Math.min(P.hp.cur ?? hpMax, hpMax));

  // 真元（同理）
  const mpMax = d['真元上限'];
  if (!P.mp) P.mp = { cur:mpMax, max:mpMax };
  P.mp.max = mpMax;
  P.mp.cur = Math.max(0, Math.min(P.mp.cur ?? mpMax, mpMax));

  // 畫面更新
  qs('#barSta').style.width = (P.sta.cur / P.sta.max * 100) + '%';
  qs('#txtSta').textContent = `${P.sta.cur}/${P.sta.max}`;

  qs('#barExp').style.width = (P.exp.cur / P.exp.max * 100) + '%';
  qs('#txtExp').textContent = `${P.exp.cur}/${P.exp.max}`;

  qs('#barHp').style.width  = (P.hp.cur / P.hp.max * 100) + '%';
  qs('#txtHp').textContent  = `${P.hp.cur}/${P.hp.max}`;

  if (qs('#barMp')) {
    qs('#barMp').style.width = (P.mp.cur / P.mp.max * 100) + '%';
    qs('#txtMp').textContent = `${P.mp.cur}/${P.mp.max}`;
  }
}

function buildMapUI(){
  const bigCol   = qs('#bigMapCol');
  const smallCol = qs('#smallMapCol');
  bigCol.innerHTML=''; smallCol.innerHTML='';

  // 左列：大地圖（清單＋建議等級）
  MAPS.forEach(m=>{
    const btn = document.createElement('div');
    btn.className = 'tag' + (m.id===curBig?' active':'');
    btn.innerHTML = `<span class="name">${m.name}</span><span class="lv">建議 ${m.lv||'—'}</span>`;
    btn.onclick = ()=>{
      curBig = m.id;
      curSmall = null;      // 切換大地圖時清空副地圖選擇
      entered = false;      // 必須重新進入
      buildMapUI();
      setLocBadge();
      updateActionPanel();
    };
    bigCol.appendChild(btn);
  });

  // 若尚未選擇，預設選第一個大地圖
  const big = MAPS.find(x=>x.id===curBig) || MAPS[0];
  if(!curBig && big){ curBig = big.id; }

  // 右列：依目前大地圖顯示副地圖（清單＋建議等級）
  (big?.small||[]).forEach(s=>{
    const btn = document.createElement('div');
    btn.className = 'tag' + (s.id===curSmall?' active':'');
    btn.innerHTML = `<span class="name">${s.name}</span><span class="lv">建議 ${s.lv||'—'}</span>`;
    btn.onclick = ()=>{
      curSmall = s.id;
      entered = false;    // 選了副地圖後，仍需按「進入」
      setLocBadge();
      updateActionPanel();

      // 標記 active
      Array.prototype.slice.call(smallCol.children).forEach(function(x){
      x.classList.remove('active');
    });
      btn.classList.add('active');

      // 更新地區情報
      renderAreaInfo();
    };
    smallCol.appendChild(btn);
  });

  setLocBadge();
  updateActionPanel();
  renderAreaInfo(); // 初始也渲染一次
}

/* 固定欄位：地區情報 */
/* 固定欄位：地區情報（不用可選鏈/未宣告變數） */
function renderAreaInfo(){
  var box = qs('#infoMonsters');

  // 依 curBig / curSmall 找到目前的小地圖
  var big = null, s = null;
  for (var i=0;i<MAPS.length;i++){
    if (MAPS[i].id === curBig){ big = MAPS[i]; break; }
  }
  if (big && big.small){
    for (var j=0;j<big.small.length;j++){
      if (big.small[j].id === curSmall){ s = big.small[j]; break; }
    }
  }
  if (!s){
    box.innerHTML = '<span class="chip">—</span>';
    return;
  }

  var chips = [];
  var list = s.monsters || [];
  for (var k=0;k<list.length;k++){
    var id = list[k];
    var m = (window.MonsterDB && MonsterDB.get) ? MonsterDB.get(id) : null;
    if(!m){
      chips.push('<span class="chip"><span class="mname">'+id+'</span></span>');
    }else{
      var el = (window.ELEMENT_LABEL && ELEMENT_LABEL[m.element]) || '無';
      chips.push(
        '<span class="chip">' +
          '<span class="pill elem '+(m.element||'none')+'">'+ el +'</span>' +
          '<span class="mname">'+ m.name +'</span><span class="mlv">LV.'+(m.level||1)+'</span>' +
        '</span>'
      );
    }
  }

  if (s.boss){
    var b = (window.MonsterDB && MonsterDB.get) ? MonsterDB.get(s.boss) : null;
    if (b){
      var elb = (window.ELEMENT_LABEL && ELEMENT_LABEL[b.element]) || '無';
      chips.push(
        '<span class="chip" style="border-color:#dc2626;background:rgba(220,38,38,.12)">' +
          '<strong>BOSS</strong>' +
          '<span class="pill elem '+(b.element||'none')+'">'+ elb +'</span>' +
          '<span class="mname">'+ b.name +'</span><span class="mlv">LV.'+(b.level||1)+'</span>' +
        '</span>'
      );
    }
  }

  box.innerHTML = chips.join('');
}


function setLocBadge(){
  const big = MAPS.find(x=>x.id===curBig);
  const small = big?.small?.find(x=>x.id===curSmall);
  const locTxt = small ? `目前位置：${big.name} ＞ ${small.name}` : '尚未選擇地點';
  qs('#locBadge').textContent = entered ? `${locTxt}（已進入）` : locTxt;
}

function getSlimeProg(){
  P.mapProg = P.mapProg || {};
  P.mapProg.slime_cave = P.mapProg.slime_cave || { kills:0, bossReady:false };
  return P.mapProg.slime_cave;
}

function updateBossUI(){
  const hint = qs('#slimeQuestHint');
  const btnBoss = qs('#btnBoss');
  if(!hint || !btnBoss) return;

  if(curSmall !== 'slime_cave'){
    hint.style.display = 'none';
    btnBoss.style.display = 'none';
    return;
  }

  const prog = getSlimeProg();
  // 只有已進入該區時才顯示提示
  if(!entered){
    hint.style.display = 'none';
    btnBoss.style.display = 'none';
    return;
  }

  // 顯示當前進度
  if(prog.bossReady){
    hint.textContent = `萊姆洞窟：討伐已達 10/10 → 可以挑戰 BOSS（未擊敗前，擊殺數不再累加）`;
    hint.style.display = 'block';
    btnBoss.style.display = 'inline-block';
  }else{
    hint.textContent = `萊姆洞窟：史萊姆討伐進度 ${prog.kills}/10（達 10/10 將出現 BOSS 按鈕）`;
    hint.style.display = 'block';
    btnBoss.style.display = 'none';
  }
}

function updateActionPanel(){
  const btnEnter   = qs('#btnEnter');
  const btnExplore = qs('#btnExplore');
  const btnFight   = qs('#btnFight');

  const canEnter = !!curBig && !!curSmall;
  btnEnter.disabled = !canEnter;

  if(!entered){
    btnEnter.style.display   = 'inline-block';
    btnExplore.style.display = 'none';
    btnFight.style.display   = 'none';
  }else{
    btnEnter.style.display   = 'none';
    btnExplore.style.display = 'inline-block';
    btnFight.style.display   = 'inline-block';
  }

  // ★ 同步更新 BOSS UI
  updateBossUI();
}

/* ===== 探險 ===== */
function doExplore(){
  if(!curSmall){ log('請先選擇副地圖。'); return; }
  if(!entered){ log('請先按「進入」該地區。'); return; }

  var staCur = (P && P.sta && typeof P.sta.cur === 'number') ? P.sta.cur : 0;
  if(staCur < 2){ log('體力不足（需要 2）', 'warn'); return; }
  P.sta.cur = staCur - 2;

  var r = Math.random();
  if(r < 0.5){
    var got = 5 + Math.floor(Math.random()*16); // 5~20
    P.currencies.stone = (P.currencies.stone||0) + got;
    log('探險獲得 靈石 ×' + got, 'ok');
  }else if(r < 0.8){
    // 素材
    var picks = ['wood_shard','stone_core','ghost_essence'];
    var id = picks[Math.floor(Math.random()*picks.length)];
    var hasDef = (ItemDB && typeof ItemDB.getDef==='function' && ItemDB.getDef('materials', id));
    if(!hasDef){ id = 'wood_shard'; }
    var qty = 1 + Math.floor(Math.random()*2);
    if(ItemDB && typeof ItemDB.addMaterialToBag==='function') ItemDB.addMaterialToBag(P.bag, id, qty);
    var mdef = (ItemDB && ItemDB.getDef) ? ItemDB.getDef('materials', id) : null;
    var mname = (mdef && mdef.name) ? mdef.name : id;
    log('探險獲得素材：' + mname + ' ×' + qty, 'ok');
  }else{
    // 消耗品
    var ids = ['hp_small','mp_small'];
    var filtered = [];
    for (var i=0; i<ids.length; i++){
      var ok = (ItemDB && typeof ItemDB.getDef==='function' && ItemDB.getDef('consumables', ids[i]));
      if(ok) filtered.push(ids[i]);
    }
    var cid = filtered.length ? filtered[Math.floor(Math.random()*filtered.length)] : 'hp_small';
    if(ItemDB && typeof ItemDB.addConsumableToBag==='function') ItemDB.addConsumableToBag(P.bag, cid, 1);
    var cdef = (ItemDB && ItemDB.getDef) ? ItemDB.getDef('consumables', cid) : null;
    var cname = (cdef && cdef.name) ? cdef.name : cid;
    log('探險獲得丹藥：' + cname + ' ×1', 'ok');
  }
  renderHeader(); renderBars(); savePlayer();
}




const ATB_MAX = 1000;      // 滿格門檻
let battle = null;         // 戰鬥狀態
let loop = null;           // 計時器


function startBattle(){
  if(!curSmall){ log('請先選擇副地圖。'); return; }
  if(!entered){ log('請先按「進入」該地區。'); return; }

  // 不用 ?. 與 find：用傳統 for 迴圈找區域
  var big = null, area = null, i, j;
  for (i = 0; i < MAPS.length; i++){
    if (MAPS[i].id === curBig){ big = MAPS[i]; break; }
  }
  if (big && big.small){
    for (j = 0; j < big.small.length; j++){
      if (big.small[j].id === curSmall){ area = big.small[j]; break; }
    }
  }
  if(!area){ log('找不到該地區'); return; }

  // 若有指定怪（例如 BOSS）則強制該怪；否則隨機
  var enemy = null;
  if(window.FORCE_MONSTER_ID){
    var def = (window.MonsterDB && MonsterDB.DB) ? MonsterDB.DB[window.FORCE_MONSTER_ID] : null;
    if(def) enemy = JSON.parse(JSON.stringify(def));
    window.FORCE_MONSTER_ID = null; // 用完即清
  }
  if(!enemy){
    var pool = [];
    if (area.monsters && window.MonsterDB && MonsterDB.DB){
      for (i = 0; i < area.monsters.length; i++){
        var mid = area.monsters[i];
        var mdef = MonsterDB.DB[mid];
        if (mdef) pool.push(mdef);
      }
    }
    if(!pool.length){ log('此地尚無怪物資料'); return; }
    enemy = JSON.parse(JSON.stringify(pool[Math.floor(Math.random()*pool.length)]));
  }

  // 初始化戰鬥畫面
  qs('#mapSection').style.display = 'none';
  qs('#battleSection').classList.add('show');
  if (loop){ clearInterval(loop); loop = null; }

  // 1) 玩家最終衍生值：進入戰鬥前刷新一次快照，只讀 P._live
  refreshLive();
  var d = (P && P._live) ? P._live : {};

  // 2) 敵人使用資料庫的「固定 stats」，若缺 acc/eva 以 deriveAgainst 或預設值補齊
  var eBase = (enemy && enemy.stats) ? enemy.stats : {};
  var derived = null;
  try{
    if (window.MonsterDB && MonsterDB.deriveAgainst && P && P._live){
      derived = MonsterDB.deriveAgainst(P._live, enemy.id) || null;
    }
  }catch(_err){ derived = null; }

  function pick(key, fallback){
    var v0 = (typeof eBase[key] === 'number') ? eBase[key] : null;
    if (v0 != null && v0 > 0) return v0;
    if (derived && typeof derived[key] === 'number' && derived[key] > 0) return derived[key];
    return (typeof fallback === 'number') ? fallback : 0;
  }

  var eStats = {
    atk  : (eBase.atk  | 0),
    matk : (eBase.matk | 0),
    def  : (eBase.def  | 0),
    mdef : (eBase.mdef | 0),
    acc  : pick('acc', 75),  // 缺就補：預設 75
    eva  : pick('eva', 5),   // 缺就補：預設 5
    crit : (eBase.crit | 0),
    aspd : (typeof eBase.aspd === 'number' ? eBase.aspd : 1.00),
    pen  : 0                 // 目前怪物未定義破甲
  };

// 初始化戰鬥物件（全部用固定 DB）
battle = {
  enemy,
  enemyStats: eStats,
  p:{
    hp   : P.hp?.cur || 100,
    hpMax: P.hp?.max || 100,
    mp   : P.mp?.cur || 0,
    mpMax: P.mp?.max || 0,
    atb  : 0,
    // 玩家行動速度＝最終衍生的「行動條速度」；至少 50，避免太慢
    speed: Math.max(50, d['行動條速度'] || 100),
  },
  e:{
    hp   : (eBase.hp || 100),
    hpMax: (eBase.hp || 100),
    atb  : 0,
    // 敵人速度用 aspd（倍率）投影到同一尺度；至少 50
    speed: Math.max(50, Math.round((eStats.aspd || 1) * 100)),
  },


  turn:'none', over:false,
};

  qs('#eName').textContent = enemy.name;
  qs('#eLv').textContent = enemy.level;
  qs('#pLv').textContent = P.level;

  // === 新增：顯示雙方元素膠囊 ===
  const getElemLabel = (k)=> (ELEMENT_LABEL?.[k] || k);
  const pElem = (P.element || P.elem || 'none');
  const eElem = (enemy.element || enemy.elem || 'none');

  const pEl = qs('#pElem'), eEl = qs('#eElem');
  if (pEl) { pEl.textContent = getElemLabel(pElem); pEl.className = 'pill elem ' + pElem; }
  if (eEl) { eEl.textContent = getElemLabel(eElem); eEl.className = 'pill elem ' + eElem; }

  // 額外：進場提示一次雙方元素
  log(`元素資訊｜你：${getElemLabel(pElem)}　敵人：${getElemLabel(eElem)}`);


  const pSrc = (P.avatar && typeof P.avatar==='string' && P.avatar.trim()) ? P.avatar : PLAYER_IMG_URL;
  const pic = (window.MonsterDB && MonsterDB.getImage) ? MonsterDB.getImage(enemy.id) : {url:'',mirror:false};
  const pImg = qs('#pImg'); const eImg = qs('#eImg');
  if(pImg) pImg.src = pSrc;
  if(eImg){ eImg.src = pic.url || ''; eImg.classList.toggle('mirror', !!pic.mirror); }

  updateBattleBars();
  updateCmdEnabled();
  log(`在 ${area.name} 遭遇 ${enemy.name}！`);
  loop = setInterval(tickATB, 60);
}

function tickATB(){
  if(!battle || battle.over) return;

  // 玩家滿條就「暫停時間」（等待玩家選指令，不再讓敵人繼續充）
  if (battle.p.atb >= ATB_MAX) {
    updateCmdEnabled();
    updateBattleBars();
    return;
  }

  // 充能：以速度/5 做步進，並設定最小值 3，避免過慢
  const pStep = Math.max(3, Math.floor(battle.p.speed/5));
  const eStep = Math.max(3, Math.floor(battle.e.speed/5));

  battle.p.atb = clamp(battle.p.atb + pStep, 0, ATB_MAX);
  battle.e.atb = clamp(battle.e.atb + eStep, 0, ATB_MAX);

  updateBattleBars();
  updateCmdEnabled();

  // 敵人自動：滿就出手
  if (battle.e.atb >= ATB_MAX){
    enemyAttack();
    battle.e.atb = 0;
    updateBattleBars();
  }
}

function updateBattleBars(){
  // 更新戰鬥區顯示
  qs('#pHp').style.width  = pct(battle.p.hp, battle.p.hpMax) + '%';
  qs('#eHp').style.width  = pct(battle.e.hp, battle.e.hpMax) + '%';
  qs('#pATB').style.width = pct(battle.p.atb, ATB_MAX) + '%';
  qs('#eATB').style.width = pct(battle.e.atb, ATB_MAX) + '%';
  qs('#btState').textContent = battle.over ? '戰鬥結束' : (battle.p.atb>=ATB_MAX?'輪到你行動':'等待行動條…');

  // 同步玩家角色物件
  if(P && P.hp){
    P.hp.cur = battle.p.hp;
    P.hp.max = battle.p.hpMax;
  }
  if(P && P.mp){
    P.mp.cur = battle.p.mp || P.mp.cur || 0;
    P.mp.max = battle.p.mpMax || P.mp.max || 0;
  }

  // 上方 UI 條同步
  renderBars();
}

/* ====== 受擊特效：浮字 + 閃光 + 抖動 ====== */
// side: 'player' | 'enemy' ; type: 'dmg' | 'crit' | 'heal' | 'miss'
function spawnFloat(side, value, type='dmg'){
  const host = side==='player' ? qs('#pFx') : qs('#eFx');
  if(!host) return;
  const el = document.createElement('div');
  if (type==='miss'){
    el.className = 'dmg-float';
    el.textContent = 'MISS';
  }else{
    el.className = 'dmg-float ' + (type==='heal'?'heal':(type==='crit'?'crit dmg':'dmg'));
    el.textContent = (type==='heal' ? '+' : '-') + value;
  }
  host.appendChild(el);
  setTimeout(()=>{ el.remove(); }, 1000);
}

function flashShake(side){
  const img = side==='player' ? qs('#pImg') : qs('#eImg');
  const fx  = side==='player' ? qs('#pFx') : qs('#eFx');
  if(!img || !fx) return;
  // 閃
  const f = document.createElement('div');
  f.className = 'flash';
  fx.appendChild(f);
  setTimeout(()=>{ f.remove(); }, 260);
  // 抖
  img.classList.add('shake');
  setTimeout(()=> img.classList.remove('shake'), 520);
}

// 綜合顯示：受擊時呼叫；heal=true 時顯示綠字
function showHit(side, amount, isCrit=false, kind='hit'){
  if(kind==='heal'){
    spawnFloat(side, amount, 'heal');
    return;
  }
  spawnFloat(side, amount, isCrit?'crit':'dmg');
  flashShake(side);
}

function updateCmdEnabled(){
  const canAct = battle && !battle.over && battle.p.atb>=ATB_MAX;
  ['actAttack','actSkill','actItem','actRun'].forEach(id=>{ qs('#'+id).disabled = !canAct; });
}

function calcDamage(isPlayer){
  const clamp01 = (x,min,max)=> Math.max(min, Math.min(max, x));
  const hitChanceOf = (attAcc, defEva, base=75)=> clamp01(base + (attAcc|0) - (defEva|0), 5, 98);

  if(isPlayer){
    if (!P._live) refreshLive();
    const D = P._live;

    // 命中檢定
    const attAcc = D['命中率'] || 0;
    const defEva = (battle.enemyStats?.eva || 0);
    const hitChance = hitChanceOf(attAcc, defEva, 75);
    if (Math.random()*100 >= hitChance){
      const atkElem = P?.element || 'none';
      const defElem = battle.enemy?.element || 'none';
      return { dmg:0, miss:true, crit:false, note:'', elemMul:1, stabMul:1, atkElem, defElem, hitChance };
    }

    // 傷害（與原來相同）
    const atk = D['物理攻擊'];
    const pen = D['破甲']||0;
    const critRate = D['暴擊率']||0;
    const critDmg  = (100 + (D['暴擊傷害']||50)) / 100;
    const eDef = Math.max(0, (battle.enemyStats?.def || 0) - pen);
    let base = Math.max(1, atk - eDef);
    base = Math.round(base * (0.9 + Math.random()*0.2));
    const isCrit = Math.random()*100 < critRate;
    let out = Math.max(1, Math.round(base * (isCrit ? critDmg : 1)));

    const atkElem = P?.element || 'none';
    const defElem = battle.enemy?.element || 'none';
    const elemMul = elemMult(atkElem, defElem);
    const stabMul = (atkElem!=='none') ? (window.STAB||1) : 1;
    out = Math.max(1, Math.round(out * elemMul * stabMul));

    let note = '';
    if (elemMul > 1)      note += `（屬性剋制 ×${elemMul.toFixed(2)}）`;
    else if (elemMul < 1) note += `（被克制 ×${elemMul.toFixed(2)}）`;
    if (stabMul > 1)      note += `（同屬加成 +${Math.round((stabMul-1)*100)}%）`;

    return { dmg: out, miss:false, crit:isCrit, note, elemMul, stabMul, atkElem, defElem, hitChance };
  }else{
    const eS = battle.enemyStats || {};

    // 命中檢定（敵方 → 我方）
    if (!P._live) refreshLive();
    const attAcc = eS.acc || 0;
    const defEva = P._live['閃避'] || 0;
    const hitChance = hitChanceOf(attAcc, defEva, 75);
    if (Math.random()*100 >= hitChance){
      const atkElem = battle.enemy?.element || 'none';
      const defElem = P?.element || 'none';
      return { dmg:0, miss:true, crit:false, note:'', elemMul:1, stabMul:1, atkElem, defElem, hitChance };
    }

    // 傷害（與原來相同）
    const atk = Math.max(1, eS.atk || 8);
    const pen = Math.max(0, eS.pen || 0);
    const pDef0  = Math.max(0, (P._live['物理防禦']||0));
    const effDef = Math.max(0, pDef0 - pen);

    let base = Math.max(1, atk - effDef);
    base = Math.round(base * (0.9 + Math.random()*0.2));
    let out = Math.max(1, Math.round(base));

    const atkElem = battle.enemy?.element || 'none';
    const defElem = P?.element || 'none';
    const elemMul = elemMult(atkElem, defElem);
    const stabMul = (atkElem!=='none') ? (window.STAB||1) : 1;
    out = Math.max(1, Math.round(out * elemMul * stabMul));

    return { dmg: out, miss:false, crit:false, note:'', elemMul, stabMul, atkElem, defElem, hitChance };
  }
}


function playerAttack(){
  const r = calcDamage(true);
  if (r.miss){
    spawnFloat('enemy', 0, 'miss');
    log(`你攻擊落空！（命中機率 ${Math.round(r.hitChance)}%）`, 'warn');
  }else{
    battle.e.hp = clamp(battle.e.hp - r.dmg, 0, battle.e.hpMax);
    showHit('enemy', r.dmg, !!r.crit, 'hit');
    const rel = elemRelationText(r.atkElem, r.defElem, r.elemMul, r.stabMul);
    log(`你對 ${battle.enemy.name} 造成 ${r.dmg} 傷害${r.crit?'（暴擊）':''} ${rel}`);
  }
  battle.p.atb = 0;
  endCheck();
  updateBattleBars(); updateCmdEnabled();
  if(!battle.over && battle.e.atb>=ATB_MAX){ enemyAttack(); battle.e.atb=0; updateBattleBars(); }
}




function enemyAttack(){
  const E = battle.enemy || {};
  const skills = E.skills || [];

  // --- 有技能就判定是否施放 ---
  if (skills.length){
    const s = skills[0]; // 目前只放一招：萊姆波動
    const hpRate = Math.max(0, battle.e.hp) / Math.max(1, battle.e.hpMax);
    let useChance = (s.chance ?? 0) + ((hpRate < 0.5) ? (s.lowHpBonus ?? 0) : 0);
    if (Math.random() < useChance){
      // ★ 法術打擊（立即傷害）
      const magic = calcMagicDamageFromEnemy(s.elem || 'none');
      battle.p.hp = clamp(battle.p.hp - magic.dmg, 0, battle.p.hpMax);
      showHit('player', magic.dmg, false, 'hit');
      const rel = elemRelationText(magic.atkElem, magic.defElem, magic.elemMul, magic.stabMul);
      log(`${E.name} 施放「${s.name}」，對你造成 ${magic.dmg} 法術傷害 ${rel}`);

      // ★ 附加 DoT（每秒 -dps，持續 duration 秒）
      applyDotToPlayer(s.dps|0, s.duration|0, s.name);

      endCheck();
      updateBattleBars();
      return;
    }
  }

// --- 否則用一般攻擊 ---
const r = calcDamage(false);
if (r.miss){
  spawnFloat('player', 0, 'miss');
  log(`${E.name} 的攻擊落空！（命中機率 ${Math.round(r.hitChance)}%）`, 'warn');
}else{
  battle.p.hp = clamp(battle.p.hp - r.dmg, 0, battle.p.hpMax);
  showHit('player', r.dmg, false, 'hit');
  const rel = elemRelationText(r.atkElem, r.defElem, r.elemMul, r.stabMul);
  log(`${E.name} 對你造成 ${r.dmg} 傷害 ${rel}`);
}
endCheck();
updateBattleBars();


}

// 工具：用敵方「法術攻擊 vs 我方法術防禦」走一套獨立公式（含元素）
function calcMagicDamageFromEnemy(atkElem='none'){
  const eS = battle.enemyStats || {};
  const matk = Math.max(1, eS.matk || 8);
  const mpen = Math.max(0, eS.mpen || 0);

  if (!P._live) refreshLive();
  const pMdef0  = Math.max(0, (P._live['法術防禦']||0));
  const effMdef = Math.max(0, pMdef0 - mpen);

  let base = Math.max(1, matk - effMdef);
  base = Math.round(base * (0.9 + Math.random()*0.2));
  let out = Math.max(1, Math.round(base));

  const defElem = P?.element || 'none';
  const elemMul = elemMult(atkElem, defElem);
  const stabMul = (atkElem!=='none') ? (window.STAB||1) : 1;

  out = Math.max(1, Math.round(out * elemMul * stabMul));
  return { dmg: out, atkElem, defElem, elemMul, stabMul };
}

// 工具：套用 DoT（每秒傷害、持續秒數）
function applyDotToPlayer(dps, seconds, label='持續傷害'){
  if(!battle.dotTimers) battle.dotTimers = [];
  let t = 0;
  const timer = setInterval(()=>{
    if(!battle || battle.over){ clearInterval(timer); return; }
    if(battle.p.hp<=0 || battle.e.hp<=0){ clearInterval(timer); return; }
    t++;
    battle.p.hp = clamp(battle.p.hp - Math.max(0,dps|0), 0, battle.p.hpMax);
    showHit('player', Math.max(0,dps|0), false, 'hit');
    log(`【持續傷害】${label}：-${dps}（${t}/${seconds}）`, 'warn');
    updateBattleBars();
    endCheck();
    if(t>=seconds) clearInterval(timer);
  }, 1000);
  battle.dotTimers.push(timer);
}




function useItem(){
  const bag = P.bag || {};
  const list = (bag.consumables || []).filter(x=>x && x.count>0);
  if(!list.length){
    log('沒有可用的消耗品','warn');
    return;
  }

  // 建立簡單選單 UI
  const menu = document.createElement('div');
  menu.style.position='fixed';
  menu.style.inset='0';
  menu.style.background='rgba(0,0,0,0.6)';
  menu.style.zIndex='9999';
  menu.style.display='grid';
  menu.style.placeItems='center';

  const box = document.createElement('div');
  box.style.background='#1e293b';
  box.style.padding='12px';
  box.style.borderRadius='12px';
  box.style.maxWidth='300px';
  box.style.display='grid';
  box.style.gap='8px';

  const title = document.createElement('div');
  title.textContent = '選擇要使用的消耗品';
  title.style.fontWeight='700';
  title.style.marginBottom='6px';
  box.appendChild(title);

  list.forEach(it=>{
    const btn = document.createElement('button');
    btn.style.display='flex';
    btn.style.alignItems='center';
    btn.style.gap='6px';
    btn.style.padding='6px 8px';
    btn.style.borderRadius='8px';
    btn.style.background='rgba(255,255,255,0.08)';
    btn.style.color='#fff';
    btn.style.border='1px solid rgba(255,255,255,0.15)';
    btn.style.cursor='pointer';

    const img = document.createElement('img');
    img.src = it.icon || '';
    img.style.width='28px';
    img.style.height='28px';
    img.style.objectFit='cover';
    img.style.borderRadius='6px';

    const txt = document.createElement('div');
    txt.innerHTML = `<b>${it.name}</b> ×${it.count}<br/><small>${it.effect?.hp?`回復HP ${it.effect.hp}`:''}${it.effect?.mp?` 回復MP ${it.effect.mp}`:''}</small>`;

    btn.appendChild(img);
    btn.appendChild(txt);

    btn.onclick = ()=>{
      // 扣除數量
      it.count--; if(it.count<=0) bag.consumables = bag.consumables.filter(x=>x.count>0);

      // 套用效果
      if(it.effect?.hp){
        const heal = it.effect.hp;
        battle.p.hp = clamp(battle.p.hp + heal, 0, battle.p.hpMax);
        P.hp.cur = battle.p.hp;
        showHit('player', heal, false, 'heal');
        log(`使用 ${it.name} 回復 ${heal} 氣血。`);
      }
      if(it.effect?.mp){
        const heal = it.effect.mp;
        battle.p.mp = clamp((battle.p.mp||0) + heal, 0, battle.p.mpMax);
        P.mp.cur = battle.p.mp;
        showHit('player', heal, false, 'heal');
        log(`使用 ${it.name} 回復 ${heal} 真元。`);
      }

      battle.p.atb = 0;
      renderBars(); savePlayer();
      updateBattleBars(); updateCmdEnabled();
      menu.remove();
    };

    box.appendChild(btn);
  });

  const cancel = document.createElement('button');
  cancel.textContent='取消';
  cancel.style.marginTop='6px';
  cancel.onclick=()=>menu.remove();
  box.appendChild(cancel);

  menu.appendChild(box);
  document.body.appendChild(menu);
}



function tryRun(){
  const ok = Math.random()<0.6;
  if(ok){
    log('成功脫離戰鬥。','ok');
    finishBattle(false);
  }else{
    log('逃跑失敗！','warn');
    battle.p.atb = 0;
    updateCmdEnabled();
  }
}

function endCheck(){
  if(battle.e.hp<=0){ // 勝利
    const drops = (window.MonsterDB && MonsterDB.rollDrops) ? MonsterDB.rollDrops(battle.enemy.id) : [];
    if(window.MonsterDB && MonsterDB.applyDrops) MonsterDB.applyDrops(P, drops);
    const rank = (window.MonsterDB && MonsterDB.rankOf) ? MonsterDB.rankOf(battle.enemy.id) : 'normal';
    const expGain = (window.MonsterDB && MonsterDB.expFor)
    ? MonsterDB.expFor(battle.enemy)   // 依「怪物類型＋等級」自動算
    : (10 + Math.floor(battle.enemy.level*4)); // 後備：保留舊規則
    P.exp = P.exp || {cur:0, max:100};
    P.exp.cur += expGain;
    while(P.exp.cur >= P.exp.max){
      P.exp.cur -= P.exp.max;
      P.level = (P.level||1) + 1;
      P.unspentPoints = (P.unspentPoints||0) + 5;
      // 等級提升：回滿 HP/MP（依最新快照）
      refreshLive();
      P.hp.max = P._live['氣血上限']; P.hp.cur = P.hp.max;
      P.mp = P.mp || {cur:0, max:0};
      P.mp.max = P._live['真元上限']; P.mp.cur = P.mp.max;
      log(`升級到 LV.${P.level}！獲得屬性點 +5。`,'ok');
      P.exp.max = Math.round(P.exp.max * 1.2);
    }
    renderHeader(); renderBars(); savePlayer();
    log(`你打倒了 [${rank==='boss'?'BOSS':rank==='elite'?'菁英':'普通'}] ${battle.enemy.name}！獲得經驗 ${expGain}。`,'ok');
    if(drops?.length){
      log('掉落：' + drops.map(d=>`${d.name||d.id}×${d.amount}`).join('、'), 'ok');
    }

    // ★★ 萊姆洞窟限定：計數與重置邏輯
    if(curSmall === 'slime_cave'){
      const prog = (function(){ P.mapProg=P.mapProg||{}; P.mapProg.slime_cave=P.mapProg.slime_cave||{kills:0,bossReady:false}; return P.mapProg.slime_cave; })();

      if(battle.enemy.id === 'slime_boss'){
        // 擊敗 BOSS → 按鈕消失、計數歸 0、重新開始下一輪
        prog.bossReady = false;
        prog.kills = 0;
        log('你擊敗了萊姆王！挑戰 BOSS 按鈕已關閉，下次需再討伐 10 隻史萊姆才會出現。','ok');
      }else{
        // 只對一般史萊姆（幼體/成體）計數；當 bossReady 為真時凍結不累加
        const isNormalSlime = (battle.enemy.id==='slime_young' || battle.enemy.id==='slime');
        if(isNormalSlime && !prog.bossReady){
          prog.kills = Math.min(10, (prog.kills|0) + 1);
          if(prog.kills >= 10){
            prog.bossReady = true;
            log('討伐達 10/10！已開啟「挑戰 BOSS」按鈕。','ok');
          }else{
            log(`萊姆洞窟進度：${prog.kills}/10`,'ok');
          }
        }
      }
      savePlayer();
      updateBossUI();
    }

    // ★ 自動返回地圖
    setTimeout(()=>{ leaveBattle(); }, 1200);

  }else if(battle.p.hp<=0){
    log('你被擊倒了…（保留 1 點氣血）', 'warn');
    battle.p.hp = 1;
    if (P && P.hp) {
      P.hp.cur = 1;
      P.hp.max = battle.p.hpMax || P.hp.max;
    }
    renderBars(); savePlayer();
    setTimeout(()=>{ leaveBattle(); }, 1200);
  }
}



function finishBattle(){
  battle.over = true;
  if(loop){ clearInterval(loop); loop=null; }
  // ★ 清掉所有 DoT 計時器
  if(battle && Array.isArray(battle.dotTimers)){
    for(const tm of battle.dotTimers){ try{ clearInterval(tm); }catch(e){} }
    battle.dotTimers.length = 0;
  }
  updateBattleBars(); updateCmdEnabled();
  qs('#btnLeaveBattle').style.display='none';
}



function leaveBattle(){
  qs('#battleSection').classList.remove('show');
  qs('#btnLeaveBattle').style.display='none';
  qs('#mapSection').style.display='grid';
  battle=null;
}

/* ===== Log（同步寫入地圖＆戰鬥兩邊） ===== */
function log(t, cls){
  const targets = [ qs('#logMap'), qs('#logBattle') ].filter(Boolean);
  for(const box of targets){
    const el = document.createElement('div');
    el.textContent = t;
    if (cls) el.classList.add(cls);
    box.appendChild(el);
    // ★ 若行數過多，刪除最舊的，以免日誌過長
    while(box.childElementCount > 60){ box.removeChild(box.firstChild); }
    box.scrollTop = 1e9;
  }
}


/* ===== 事件 ===== */
function bindEvents(){
  qs('#btnBackHome').onclick = ()=>{
    if (P) { savePlayer(); }
    location.href = 'game.html';
  };
  qs('#btnLogout').onclick = ()=>{ if(window.Auth && Auth.logout) Auth.logout(); location.href='index.html'; };

  qs('#btnEnter').onclick = ()=>{
    if(!curSmall){ log('請先選擇副地圖。'); return; }
    entered = true;
    refreshLive();
    setLocBadge();
    updateActionPanel();
    log('已進入當前區域，可以進行「探險 / 戰鬥」。','ok');
  };

  qs('#btnExplore').onclick = doExplore;
  qs('#btnFight').onclick   = startBattle;
// BOSS 直進戰鬥（安全取當前小地圖）
qs('#btnBoss').onclick = function(){
  // 找到目前的小地圖資料
  var big = null, s = null;
  for (var i=0;i<MAPS.length;i++){
    if (MAPS[i].id === curBig){ big = MAPS[i]; break; }
  }
  if (big && big.small){
    for (var j=0;j<big.small.length;j++){
      if (big.small[j].id === curSmall){ s = big.small[j]; break; }
    }
  }
  var bossId = s && s.boss;
  if (!bossId) return;               // 此地沒有 BOSS 就不動
  window.FORCE_MONSTER_ID = bossId;  // 交給既有的 startBattle 流程
  startBattle();
};



  qs('#actAttack').onclick = playerAttack;
  qs('#actItem').onclick   = useItem;
  qs('#actRun').onclick    = tryRun;

  qs('#btnLeaveBattle').onclick = leaveBattle;
}

/* ===== 啟動（改為等雲端載入）===== */
window.addEventListener('DOMContentLoaded', async function(){
  // 先檢查是否已登入
  var user = (window.Auth && Auth.currentUser) ? Auth.currentUser() : null;
  if(!user){ location.href = 'index.html'; return; }

  // 從雲端載入角色（不要只用快取）
  var char = null;
  try{
    char = (window.Auth && Auth.loadCharacter) ? (await Auth.loadCharacter()) : null;
  }catch(e){
    char = null;
  }
  if(!char){ location.href = 'index.html#create'; return; }

  // 成功載入 → 用原本流程建立 P 並渲染
  P = loadPlayer(); if(!P) return;
  renderHeader(); renderBars();
  buildMapUI();
  bindEvents();
});


</script>
</body>
</html>
